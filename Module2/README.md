# **Module 2**



### **Проверка текущей таблицы маршрутизации**  
Просмотр текущих маршрутов:  
```bash
route -n
```
**Пример вывода:**  
```
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
0.0.0.0         192.168.1.1     0.0.0.0         UG    100    0        0 eth0
192.168.1.0     0.0.0.0         255.255.255.0   U     0      0        0 eth0
10.0.0.0        192.168.1.2     255.255.255.0   UG    100    0        0 eth1
```

### **Объяснение вывода**  
- **Destination** – целевая сеть или хост  
- **Gateway** – шлюз, через который передаются пакеты  
- **Genmask** – маска сети, определяет диапазон адресов  
- **Flags** – дополнительные параметры маршрута  
- **Metric** – приоритет маршрута (меньше = выше приоритет)  
- **Iface** – интерфейс, через который работает маршрут  

### **Флаги маршрутов**  
- **U** – маршрут активен  
- **G** – используется шлюз  
- **H** – маршрут ведёт к конкретному хосту  
- **D** – добавлен динамически  
- **M** – изменён динамически  

---

### **Добавление маршрутов**  
Если необходимо направить трафик в другую сеть или к конкретному хосту, можно добавить статический маршрут.

#### **Добавление маршрута к сети через шлюз**  
Используется, если сети соединены через маршрутизатор:  
```bash
sudo route add -net 192.168.2.0 netmask 255.255.255.0 gw 192.168.1.1
```
- `192.168.2.0` – целевая сеть  
- `255.255.255.0` – маска сети  
- `192.168.1.1` – шлюз (роутер)  

#### **Добавление маршрута к отдельному хосту через шлюз**  
Если доступ нужен только к одному серверу:  
```bash
sudo route add -host 192.168.2.100 gw 192.168.1.1
```
- `192.168.2.100` – IP-адрес хоста  
- `192.168.1.1` – шлюз для передачи пакетов  

#### **Добавление маршрута без использования шлюза**  
Если сеть доступна напрямую через другой интерфейс:  
```bash
sudo route add -net 10.0.0.0 netmask 255.255.255.0 dev eth1
```
- `10.0.0.0` – целевая сеть  
- `eth1` – интерфейс, через который доступна сеть  

#### **Добавление маршрута по умолчанию**  
Шлюз по умолчанию используется для отправки трафика во внешний интернет:  
```bash
sudo route add default gw 192.168.1.1
```
- Весь трафик, не относящийся к локальным маршрутам, будет идти через `192.168.1.1`.  

---

### **Удаление маршрутов**  
Если нужно убрать ненужные маршруты, используются команды удаления.

#### **Удаление маршрута к сети**  
```bash
sudo route del -net 192.168.2.0 netmask 255.255.255.0
```
#### **Удаление маршрута к хосту**  
```bash
sudo route del -host 192.168.2.100
```
#### **Удаление маршрута по умолчанию**  
```bash
sudo route del default
```

---

`sysctl` в Linux — это утилита командной строки, которая используется для управления параметрами ядра операционной системы в реальном времени. Эти параметры контролируют различные аспекты работы системы, такие как управление сетью, производительность, безопасность и другие настройки ядра.

С помощью `sysctl` можно:
- Просматривать текущие значения параметров ядра.
- Изменять параметры без необходимости перезагружать систему.
- Сохранять изменения, чтобы они сохранялись при перезагрузке.

Для использования команды, например, чтобы проверить значение параметра, можно использовать:

```
sysctl параметр
```

Для изменения параметра:

```
sysctl -w параметр=значение
```

Параметры ядра обычно находятся в директории `/proc/sys`, и через `sysctl` можно получить доступ к этим файлам, не открывая их вручную.


### **Включение маршрутизации в ядре Linux**  
По умолчанию Linux не пересылает пакеты между интерфейсами. Чтобы включить маршрутизацию:

#### **Проверка текущего состояния**  
```bash
cat /proc/sys/net/ipv4/ip_forward
```
- `0` – маршрутизация выключена  
- `1` – маршрутизация включена  

#### **Включение маршрутизации временно**  
```bash
echo 1 > /proc/sys/net/ipv4/ip_forward
```
- Работает до перезагрузки  

---

### **Постоянное включение маршрутизации**  
Чтобы маршрутизация сохранялась после перезагрузки, изменяем конфигурацию.

#### **Редактирование `/etc/sysctl.conf`**  
```bash
sudo nano /etc/sysctl.conf
```
Находим строку:
```ini
#net.ipv4.ip_forward = 1
```
Убираем `#`, чтобы получилось:
```ini
net.ipv4.ip_forward = 1
```
#### **Применение изменений**  
```bash
sudo sysctl -p
```
Теперь Linux будет автоматически пересылать пакеты между интерфейсами.

---

### **Проверка работы маршрутизации**  

#### **Проверка доступности удалённой сети**  
```bash
ping -c 4 192.168.2.1
```
Если пинг проходит – маршрут работает.  

#### **Трассировка маршрута до удалённого узла**  
```bash
traceroute 192.168.2.1
```
Показывает все промежуточные узлы.  

#### **Просмотр текущих маршрутов**  
```bash
route -n
```

---

- `route -n` показывает текущие маршруты  
- `route add` добавляет статические маршруты  
- `route del` удаляет ненужные маршруты  
- `/proc/sys/net/ipv4/ip_forward` включает маршрутизацию  
- `/etc/sysctl.conf` сохраняет настройки после перезагрузки  







### **Динамическая маршрутизация в Linux с использованием Quagga**  

Quagga — это мощный пакет для динамической маршрутизации в Linux, который поддерживает различные протоколы, такие как **RIP, OSPF, BGP, IS-IS**. Он построен по модульному принципу, где каждый протокол реализуется в виде отдельного демона.  

---

### **Модульная структура Quagga**  

Quagga разделена на несколько процессов (демонов), каждый из которых отвечает за определённые задачи:  

#### **Основной демон Zebra**  
`zebra` – центральный компонент, который управляет маршрутизацией, сетевыми интерфейсами, статическими маршрутами и взаимодействием между другими демонами. Он выполняет роль ядра маршрутизатора.

#### **Поддерживаемые протоколы и их демоны**  
- **RIP (Routing Information Protocol)**  
  - `ripd` – демон для RIP v2 (IPv4)  
  - `ripngd` – демон для RIPng (IPv6)  
- **OSPF (Open Shortest Path First)**  
  - `ospfd` – демон для OSPF v2 (IPv4)  
  - `ospf6d` – демон для OSPF v3 (IPv6)  
- **IS-IS (Intermediate System to Intermediate System)**  
  - `isisd` – демон для IS-IS  
- **BGP (Border Gateway Protocol)**  
  - `bgpd` – демон для BGP  
- **Дополнительные функции**  
  - `pimd` – поддержка **PIM-SM (Protocol Independent Multicast)**  
  - `ldpd` – реализация **MPLS LDP (Label Distribution Protocol)**  
  - `babeld` – поддержка **Babel routing protocol**  

---

### **Установка Quagga**  

В зависимости от дистрибутива устанавливается так:  

**Debian / Ubuntu:**  
```bash
sudo apt update
sudo apt install quagga -y
```
**CentOS / AlmaLinux:**  
```bash
sudo dnf install quagga -y
```

После установки необходимо включить и запустить службу:  
```bash
sudo systemctl enable zebra
sudo systemctl start zebra
```

---

### **Настройка Zebra**  

Конфигурационный файл Zebra:  
```bash
sudo nano /etc/quagga/zebra.conf
```
Пример базовой конфигурации:  
```ini
hostname Router1
password zebra
enable password zebra
log file /var/log/zebra.log
```
Применение конфигурации:  
```bash
sudo systemctl restart zebra
```

---

### **Настройка динамических протоколов**  

#### **Настройка RIP**  
Редактируем конфигурацию RIP:  
```bash
sudo nano /etc/quagga/ripd.conf
```
Добавляем:  
```ini
router rip
 network 192.168.1.0/24
 network 10.0.0.0/8
 redistribute connected
```
Включаем демон:  
```bash
sudo systemctl enable ripd
sudo systemctl restart ripd
```

#### **Настройка OSPF**  
Открываем `ospfd.conf`:  
```bash
sudo nano /etc/quagga/ospfd.conf
```
Пример конфигурации:  
```ini
router ospf
 network 192.168.1.0/24 area 0
 network 10.0.0.0/8 area 0
```
Запускаем OSPF:  
```bash
sudo systemctl enable ospfd
sudo systemctl restart ospfd
```

#### **Настройка BGP**  
Открываем `bgpd.conf`:  
```bash
sudo nano /etc/quagga/bgpd.conf
```
Пример настройки BGP для автономной системы (AS 65001):  
```ini
router bgp 65001
 neighbor 192.168.1.2 remote-as 65002
 network 192.168.1.0/24
```
Запускаем BGP:  
```bash
sudo systemctl enable bgpd
sudo systemctl restart bgpd
```

---

### **Проверка работы маршрутизации**  

Просмотр таблицы маршрутизации Zebra:  
```bash
show ip route
```

Проверка информации о соседях в OSPF:  
```bash
show ip ospf neighbor
```

Проверка BGP соединений:  
```bash
show ip bgp summary
```

---







`vtysh` — это командная оболочка, которая используется для взаимодействия с сетевыми сервисами, такими как **FRRouting (FRR)**, через текстовый интерфейс. FRRouting — это набор инструментов и протоколов маршрутизации для Linux, включающий поддержку таких протоколов, как OSPF, BGP, RIP и других.

### Основные функции `vtysh`:

- **Управление маршрутизацией**: `vtysh` позволяет администраторам управлять настройками маршрутизации и протоколами маршрутизации в реальном времени, предоставляя интерфейс для взаимодействия с FRRouting.
- **Консольный интерфейс**: Это текстовая консоль, в которой можно настроить и мониторить маршрутизаторы и сети, используя команды, характерные для сетевого оборудования.
- **Поддержка различных протоколов**: Через `vtysh` можно управлять и настраивать маршрутизацию для таких протоколов, как BGP (Border Gateway Protocol), OSPF (Open Shortest Path First), RIP (Routing Information Protocol) и других.









### **Общая конфигурация Quagga: файлы `/etc/quagga/daemons` и `/etc/quagga/debian.conf`**  

Quagga использует несколько файлов конфигурации для управления своими сервисами и настройками. Два ключевых файла — это:  
- **`/etc/quagga/daemons`** – определяет, какие демоны маршрутизации должны быть запущены.  
- **`/etc/quagga/debian.conf`** – конфигурация окружения для Quagga (в Debian/Ubuntu).  

---

### **Файл `/etc/quagga/daemons` – включение необходимых демонов**  

Этот файл указывает, какие демоны маршрутизации будут запущены при старте системы. По умолчанию все они отключены.  

### **Открытие файла**
```bash
sudo nano /etc/quagga/daemons
```

### **Пример содержимого файла `/etc/quagga/daemons`**  
```ini
zebra=yes   # Основной демон маршрутизации
ripd=no     # RIP для IPv4
ripngd=no   # RIP для IPv6
ospfd=no    # OSPF для IPv4
ospf6d=no   # OSPF для IPv6
bgpd=no     # BGP
isisd=no    # IS-IS
pimd=no     # PIM для мультикаста
ldpd=no     # MPLS LDP
babeld=no   # Babel
```
### **Объяснение параметров**
- **`zebra=yes`** – включает главный сервис **Zebra**, который управляет интерфейсами и взаимодействует с таблицей маршрутизации Linux.  
- **`ripd=yes`** – включает протокол **RIP**.  
- **`ospfd=yes`** – включает протокол **OSPF v2** (для IPv4).  
- **`ospf6d=yes`** – включает протокол **OSPF v3** (для IPv6).  
- **`bgpd=yes`** – включает **BGP**.  
- **`isisd=yes`** – включает **IS-IS**.  
- **`pimd=yes`** – включает **мультикаст-маршрутизацию** (PIM).  
- **`ldpd=yes`** – включает **MPLS LDP** (Label Distribution Protocol).  

### **Применение изменений**
После внесения изменений необходимо **перезапустить Quagga**, чтобы активировать нужные демоны:  
```bash
sudo systemctl restart quagga
```

---

## **Файл `/etc/quagga/debian.conf` – системные параметры Quagga**  

Файл `/etc/quagga/debian.conf` используется в **Debian/Ubuntu** для настройки переменных среды и запуска Quagga с правильными правами.

### **Открытие файла**
```bash
sudo nano /etc/quagga/debian.conf
```

### **Пример содержимого файла `/etc/quagga/debian.conf`**  
```ini
QUAGGA_OPTIONS="--daemon"
BGPD_OPTIONS="--daemon"
OSPFD_OPTIONS="--daemon"
ZEBRA_OPTIONS="--daemon"
```
### **Объяснение параметров**
- **`QUAGGA_OPTIONS="--daemon"`** – включает фоновый режим работы.  
- **`BGPD_OPTIONS="--daemon"`** – аналогично для **BGP**.  
- **`OSPFD_OPTIONS="--daemon"`** – аналогично для **OSPF**.  
- **`ZEBRA_OPTIONS="--daemon"`** – аналогично для **Zebra**.  

### **Изменение владельца конфигурационных файлов**
Quagga использует специальные привилегированные права, поэтому нужно убедиться, что конфигурационные файлы принадлежат пользователю **quagga**:
```bash
sudo chown quagga:quagga /etc/quagga/*.conf
sudo chmod 640 /etc/quagga/*.conf
```

### **Перезапуск Quagga**
После изменения конфигурации необходимо перезапустить сервис:
```bash
sudo systemctl restart quagga
```

---

- **Файл `/etc/quagga/daemons`** определяет, какие протоколы маршрутизации активны.  
- **Файл `/etc/quagga/debian.conf`** задаёт параметры запуска сервисов в Debian/Ubuntu.  
- **После изменения конфигурации Quagga необходимо перезапустить сервис, чтобы настройки вступили в силу.**  



# **Методы конфигурирования маршрутизации в Quagga**

Quagga предоставляет два основных способа конфигурирования маршрутизации:  
1. **Редактирование конфигурационных файлов вручную**  
2. **Использование интерактивного CLI через Telnet или `vtysh`**  

При этом синтаксис команд **очень похож** на Cisco IOS, что упрощает переход на Quagga для сетевых инженеров, знакомых с Cisco.

---



### **Пример конфигурационных файлов**  
| Протокол | Файл конфигурации |
|----------|------------------|
| Zebra (базовая маршрутизация) | `/etc/quagga/zebra.conf` |
| RIP (IPv4) | `/etc/quagga/ripd.conf` |
| RIPng (IPv6) | `/etc/quagga/ripngd.conf` |
| OSPF (IPv4) | `/etc/quagga/ospfd.conf` |
| OSPF (IPv6) | `/etc/quagga/ospf6d.conf` |
| BGP | `/etc/quagga/bgpd.conf` |

### **Пример конфигурации Zebra (`/etc/quagga/zebra.conf`)**
```ini
hostname Router1
password zebra
enable password zebra
log file /var/log/zebra.log
interface eth0
 ip address 192.168.1.1/24
!
ip route 0.0.0.0/0 192.168.1.254
```
- Указываем имя маршрутизатора  
- Задаём пароли для CLI  
- Включаем логирование  
- Настраиваем интерфейс  
- Добавляем статический маршрут  

После внесения изменений **перезапускаем Quagga**:
```bash
sudo systemctl restart quagga
```

---

### ** Конфигурирование через Telnet**
Quagga запускает Telnet-сервер, через который можно управлять маршрутами.  

### **Подключение к Zebra**
```bash
telnet localhost 2601
```
Вводим пароль `zebra` (заданный в конфигурации).  

### **Пример работы в CLI**
Переход в режим конфигурации:
```bash
enable
configure terminal
```
Настройка статического маршрута:
```bash
ip route 192.168.2.0/24 192.168.1.254
```
Выход и сохранение конфигурации:
```bash
exit
write memory
```

### **Подключение к другим модулям**
| Протокол | Порт Telnet |
|----------|------------|
| Zebra | `2601` |
| RIP | `2602` |
| OSPF | `2604` |
| BGP | `2605` |

Пример подключения к BGP:
```bash
telnet localhost 2605
```

---

### **Использование `vtysh` – единый интерфейс управления**
Вместо подключения через Telnet можно использовать **vtysh** – оболочку командной строки Quagga.

### **Запуск `vtysh`**
```bash
sudo vtysh
```
В результате откроется CLI, аналогичный Cisco IOS:
```
Router1#
```

### **Основные команды в `vtysh`**
- Просмотр таблицы маршрутизации:
  ```bash
  show ip route
  ```
- Просмотр интерфейсов:
  ```bash
  show interface
  ```
- Просмотр соседей OSPF:
  ```bash
  show ip ospf neighbor
  ```
- Просмотр соседей BGP:
  ```bash
  show ip bgp summary
  ```
- Переключение в режим конфигурации:
  ```bash
  configure terminal
  ```
- Добавление маршрута:
  ```bash
  ip route 192.168.2.0/24 192.168.1.254
  ```
- Выход и сохранение:
  ```bash
  exit
  write memory
  ```

### **Сравнение `vtysh` и Telnet**
| Метод | Описание |
|-------|----------|
| **Telnet** | Подключение к конкретному демону через `telnet localhost <port>` |
| **vtysh** | Универсальный интерфейс для управления всеми модулями |

---


- **Конфигурационные файлы** удобны для автоматической настройки.  
- **Telnet** даёт доступ к каждому демону отдельно.  
- **vtysh** – лучший способ управления, так как предоставляет единый интерфейс.  
- **Команды Quagga практически идентичны Cisco IOS**, что упрощает работу сетевым администраторам.  



### **Маршрутизация по политикам (PBR) в Linux**  
Маршрутизация по политикам (**Policy-Based Routing, PBR**) позволяет направлять трафик в зависимости от **IP-адреса источника, интерфейса или типа трафика**, а не только по стандартной таблице маршрутизации.  

#### **Стандартные таблицы маршрутизации**  
Linux использует три предустановленные таблицы:  

| Таблица  | Назначение |
|----------|-----------|
| **local** | Обслуживает локальные IP-адреса (127.0.0.1, IP-адрес интерфейса) |
| **main** | Основная таблица маршрутизации |
| **default** | Используется, если маршруты в `main` не подходят |

Посмотреть текущие таблицы можно так:  
```bash
ip route show table all
```

#### **Добавление пользовательской таблицы**  
Редактируем файл:  
```bash
sudo nano /etc/iproute2/rt_tables
```
Добавляем строку:  
```
100 custom_route
```
Проверяем:  
```bash
cat /etc/iproute2/rt_tables
```

#### **Добавление маршрутов в таблицу**  
```bash
ip route add 192.168.2.0/24 via 192.168.2.1 dev eth1 table custom_route
```
Проверяем:  
```bash
ip route show table custom_route
```

#### **Создание правил маршрутизации (`ip rule`)**  
Маршрутизация по IP-адресу источника:  
```bash
ip rule add from 192.168.218.10 table custom_route
```
Маршрутизация по интерфейсу:  
```bash
ip rule add iif eth1 table custom_route
```
Маршрутизация по порту (весь SSH-трафик):  
```bash
ip rule add fwmark 0x1 table custom_route
iptables -t mangle -A PREROUTING -p tcp --dport 22 -j MARK --set-mark 0x1
```

#### **Сохранение после перезагрузки**  
Добавляем в `/etc/rc.local`:  
```bash
#!/bin/bash
ip rule add from 192.168.218.10 table custom_route
ip route add 192.168.2.0/24 via 192.168.2.1 dev eth1 table custom_route
exit 0
```
Делаем исполняемым:  
```bash
chmod +x /etc/rc.local
```

#### **Проверка работы**  
Просмотр таблиц:  
```bash
ip route show table all
```
Просмотр правил маршрутизации:  
```bash
ip rule show
```
Тестирование маршрута:  
```bash
traceroute -s 192.168.218.10  8.8.8.8
```

- **PBR** позволяет использовать **разные таблицы маршрутизации** для разных типов трафика.  
- **Файл `/etc/iproute2/rt_tables`** создаёт пользовательские таблицы маршрутизации.  
- **Команды `ip rule add`** направляют трафик по IP, интерфейсу или порту.  
- **PBR полезна для работы с несколькими провайдерами, балансировки нагрузки и разделения трафика.**  



### **Управление трафиком с помощью `tc` (Traffic Control) из пакета `iproute2`**  
Утилита **`tc`** позволяет управлять сетевым трафиком в Linux: **ограничивать скорость, приоритизировать пакеты и балансировать нагрузку**.

#### **Основные возможности `tc`**  
- **Ограничение скорости** (shaping)  
- **Приоритизация пакетов** (scheduling)  
- **Очереди пакетов** (queueing disciplines – qdisc)  
- **Фильтрация трафика**  

---

### **Основные компоненты `tc`**
| Компонент | Описание |
|-----------|----------|
| **Qdisc (Queue Discipline)** | Определяет алгоритм обработки пакетов в очереди. |
| **Class (Классы)** | Разделение трафика на категории. |
| **Filter (Фильтры)** | Определяет, какие пакеты к какому классу относятся. |

---

### **Просмотр текущих настроек трафика**
```bash
tc qdisc show dev eth0
```

---

### **Ограничение скорости (shaping)**
#### **Ограничение исходящего трафика**
```bash
tc qdisc add dev eth0 root tbf rate 1mbit burst 32k latency 400ms
```
**Объяснение:**  
- `rate 1mbit` – ограничение скорости до **1 Мбит/с**  
- `burst 32k` – размер буфера  
- `latency 400ms` – допустимая задержка  

#### **Удаление ограничения**
```bash
tc qdisc del dev eth0 root
```

---

### **Приоритизация трафика (scheduling)**
#### **HTB (Hierarchical Token Bucket) – управление классами трафика**
Создаём корневую очередь:  
```bash
tc qdisc add dev eth0 root handle 1: htb default 10
```
Добавляем классы:  
```bash
tc class add dev eth0 parent 1: classid 1:1 htb rate 2mbit ceil 3mbit
tc class add dev eth0 parent 1: classid 1:2 htb rate 500kbit ceil 1mbit
```
Приоритизируем HTTP (порт 80):  
```bash
tc filter add dev eth0 protocol ip parent 1:0 prio 1 u32 match ip dport 80 0xffff flowid 1:1
```

---

### **Очереди пакетов (Queue Disciplines)**
#### **FIFO – простая очередь**
```bash
tc qdisc add dev eth0 root pfifo limit 100
```
100 пакетов обрабатываются по принципу **"первый пришёл – первый ушёл"**.

#### **SFQ (Stochastic Fair Queueing) – справедливое распределение**
```bash
tc qdisc add dev eth0 root sfq perturb 10
```
Полезно для **равномерного распределения нагрузки** между несколькими потоками.

---

### **Фильтрация трафика**
#### **Ограничение скорости для конкретного IP**
```bash
tc filter add dev eth0 protocol ip parent 1:0 prio 1 u32 match ip src 192.168.1.100 flowid 1:2
```
Все пакеты от **192.168.1.100** будут проходить через **ограничение 500kbit**.

---

### **Просмотр и удаление настроек**
#### **Просмотр очередей и фильтров**
```bash
tc -s qdisc show dev eth0
tc -s class show dev eth0
tc -s filter show dev eth0
```
#### **Удаление всех настроек**
```bash
tc qdisc del dev eth0 root
```

---

- **`tc` управляет трафиком**: ограничивает скорость, расставляет приоритеты.  
- **Используются `qdisc`, `class`, `filter`**:  
  - `qdisc` – очередь обработки пакетов  
  - `class` – разделение трафика  
  - `filter` – выбор пакетов по IP, порту или протоколу  
- **Можно ограничивать скорость, приоритизировать важный трафик (например, VoIP) и балансировать нагрузку.**





### **SOHO Linux-маршрутизатор с двумя провайдерами и балансировкой нагрузки**  

Настроим Linux-маршрутизатор с **двумя интернет-каналами одинаковой скорости и стоимости**, реализуя **балансировку нагрузки** между ними.

#### **Исходные данные**  
| Интерфейс | Назначение | IP-адрес | Шлюз |
|-----------|------------|---------|------|
| **eth0** | ISP1 (первый провайдер) | 192.168.1.2/24 | 192.168.1.1 |
| **eth1** | ISP2 (второй провайдер) | 192.168.2.2/24 | 192.168.2.1 |
| **eth2** | Внутренняя сеть (LAN) | 192.168.10.1/24 | - |

#### **Включение IP-маршрутизации**  
```bash
echo 1 > /proc/sys/net/ipv4/ip_forward
```
Сохранение в `/etc/sysctl.conf`:  
```ini
net.ipv4.ip_forward = 1
```
Применение:  
```bash
sysctl -p
```

#### **Настройка таблиц маршрутизации**  
Редактируем `/etc/iproute2/rt_tables`, добавляем две таблицы:  
```ini
100 isp1
200 isp2
```

#### **Добавление маршрутов для провайдеров**  
```bash
ip route add 192.168.1.0/24 dev eth0 src 192.168.1.2 table isp1
ip route add default via 192.168.1.1 table isp1

ip route add 192.168.2.0/24 dev eth1 src 192.168.2.2 table isp2
ip route add default via 192.168.2.1 table isp2
```

#### **Создание правил маршрутизации**  
```bash
ip rule add from 192.168.1.2 table isp1
ip rule add from 192.168.2.2 table isp2
```

#### **Балансировка нагрузки через `nexthop`**  
```bash
ip route add default scope global \
    nexthop via 192.168.1.1 dev eth0 weight 1 \
    nexthop via 192.168.2.1 dev eth1 weight 1
```

#### **Настройка NAT (iptables)**  
```bash
iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
iptables -t nat -A POSTROUTING -o eth1 -j MASQUERADE
```

#### **Сохранение правил iptables**  
```bash
iptables-save > /etc/iptables.rules
```

#### **Проверка работы маршрутизации**  
Просмотр текущих правил:  
```bash
ip rule show
```
Проверка таблиц маршрутизации:  
```bash
ip route show table isp1
ip route show table isp2
```
Тестирование доступа в интернет:  
```bash
ping -I eth0 8.8.8.8
ping -I eth1 8.8.8.8
```

- **Linux-маршрутизатор использует два интернет-канала одновременно**  
- **Балансировка нагрузки работает по принципу `nexthop`**  
- **Маршрутизация NAT настраивается через iptables**  
- **Правила маршрутизации сохраняются в iproute2**  




#### **Включение IP-маршрутизации**  
```bash
echo 1 > /proc/sys/net/ipv4/ip_forward
```
Сохранение в `/etc/sysctl.conf`:  
```ini
net.ipv4.ip_forward = 1
```
Применение:  
```bash
sysctl -p
```

#### **Настройка таблиц маршрутизации**  
Редактируем `/etc/iproute2/rt_tables`, добавляем две таблицы:  
```ini
100 isp1
200 isp2
```

#### **Добавление маршрутов для провайдеров**  
```bash
ip route add 192.168.1.0/24 dev eth0 src 192.168.1.2 table isp1
ip route add default via 192.168.1.1 table isp1

ip route add 192.168.2.0/24 dev eth1 src 192.168.2.2 table isp2
ip route add default via 192.168.2.1 table isp2
```

#### **Создание правил маршрутизации**  
```bash
ip rule add from 192.168.1.2 table isp1 priority 100
ip rule add from 192.168.2.2 table isp2 priority 200
```

#### **Настройка отказоустойчивости с `ip route` и `ping`-мониторингом**  
```bash
ip route add default via 192.168.1.1 dev eth0 metric 100
ip route add default via 192.168.2.1 dev eth1 metric 200
```
Этот метод сам не переключает провайдеров при отказе, поэтому добавим мониторинг.

#### **Автоматическое переключение интернет-канала (failover)**
Создадим скрипт `/root/failover.sh` для проверки доступности основного провайдера:  
```bash
#!/bin/bash

# Проверяем доступность ISP1
ping -c 3 -I eth0 8.8.8.8 > /dev/null
if [ $? -ne 0 ]; then
    echo "ISP1 недоступен, переключение на ISP2..."
    ip route del default via 192.168.1.1
    ip route add default via 192.168.2.1 dev eth1 metric 100
else
    echo "ISP1 работает нормально"
    ip route del default via 192.168.2.1
    ip route add default via 192.168.1.1 dev eth0 metric 100
fi
```

Сделаем его исполняемым и добавим в `cron` для проверки каждые 30 секунд:  
```bash
chmod +x /root/failover.sh
(crontab -l ; echo "*/1 * * * * /root/failover.sh") | crontab -
```

#### **Настройка NAT (iptables)**  
```bash
iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
iptables -t nat -A POSTROUTING -o eth1 -j MASQUERADE
```

#### **Сохранение iptables**  
```bash
iptables-save > /etc/iptables.rules
```

#### **Проверка работы маршрутизации**  
Просмотр таблиц маршрутизации:  
```bash
ip route show table isp1
ip route show table isp2
```
Тестирование основного канала:  
```bash
ping -I eth0 8.8.8.8
```
Тестирование резервного канала:  
```bash
ping -I eth1 8.8.8.8
```
Тестирование переключения:  
```bash
ip route del default via 192.168.1.1
```
После выполнения этой команды маршрутизация должна перейти на ISP2.




### **Утилита `ss` – аналог `netstat` для мониторинга сетевых соединений**  

`ss` (socket statistics) – мощный инструмент для просмотра информации о **сетевых соединениях**, **сокетах**, **прослушиваемых портах** и **сетевой активности**. Он является **быстрым и современным аналогом `netstat`**, входящим в пакет `iproute2`.

#### **Преимущества `ss` перед `netstat`**
- **Более высокая скорость** (работает напрямую с `/proc/net`).
- **Больше информации о TCP-соединениях**.
- **Поддержка детального вывода с фильтрацией по портам, адресам, состояниям**.

---

### **Просмотр всех соединений**
```bash
ss -a
```
Выводит **все TCP и UDP соединения**, включая **активные и ожидающие**.

---

### **Просмотр только активных TCP-соединений**
```bash
ss -t
```
Показывает только **TCP-соединения**.

---

### **Просмотр только UDP-соединений**
```bash
ss -u
```
Отображает **UDP-соединения**, включая серверные порты.

---

### **Прослушиваемые порты (аналог `netstat -tuln`)**
```bash
ss -tuln
```
**Разбор параметров:**
- `-t` – TCP  
- `-u` – UDP  
- `-l` – только прослушиваемые (listening) порты  
- `-n` – не преобразовывать IP в домены  

---

### **Просмотр соединений по конкретному порту**
```bash
ss -tuln | grep ":22"
```
Проверяет, **прослушивается ли порт 22 (SSH)**.

---

### **Вывод информации о процессах, занимающих порты**
```bash
ss -tunlp
```
**Дополнительные параметры:**
- `-p` – показывает **имена процессов и PID**  
- `-t` – TCP  
- `-u` – UDP  
- `-n` – не преобразовывать IP  

---

### **Просмотр соединений, установленных с конкретным IP**
```bash
ss -t dst 192.168.1.100
```
Выводит **все TCP-соединения**, направленные на **192.168.1.100**.

---

### **Просмотр соединений в определённом состоянии**
```bash
ss -t state ESTABLISHED
```
Показывает **только активные соединения**.

---

### **Вывод сокетов в формате `netstat -anp`**
```bash
ss -anp
```
Похожий вывод, но работает **быстрее и эффективнее**.

---

### **Вывод статистики по TCP**
```bash
ss -s
```
Краткая информация о **TCP-сокетах**:  
- **Количество установленных соединений**  
- **Ожидающие соединения**  
- **Закрытые соединения**  

---

### **Вывод только IPv4 или IPv6 соединений**
```bash
ss -4    # Только IPv4  
ss -6    # Только IPv6  
```

---

### **Вывод соединений с задержками (TCP RTT)**
```bash
ss -ti
```
Показывает **RTT (round-trip time)** для TCP-соединений.

---

### **Вывод информации о времени жизни соединений**
```bash
ss -o state established
```
Показывает **таймеры и время жизни активных TCP-соединений**.

---

### **Вывод соединений с фильтрацией по локальному порту**
```bash
ss -t src :80
```
Покажет **все TCP-соединения с локальным портом 80 (HTTP-сервер)**.

---

### **Вывод соединений с фильтрацией по удалённому порту**
```bash
ss -t dst :443
```
Выведет **все соединения с удалённым портом 443 (HTTPS)**.

---


- `ss` **заменяет `netstat`**, обеспечивая **быстрее и точнее** работу с сетевыми соединениями.
- Поддерживает **гибкую фильтрацию** по IP, портам и состояниям соединений.
- Полезен для **диагностики сети, отладки серверов и мониторинга соединений**.





#### **IPIP-туннель (инкапсуляция IPv4 в IPv4)**
IPIP (IP-over-IP) используется для соединения **двух удалённых IPv4-сетей** через интернет.

##### **Сервер (192.168.1.1, внешний IP 1.1.1.1)**
```bash
ip tunnel add ipip0 mode ipip remote 2.2.2.2 local 1.1.1.1
ip link set ipip0 up
ip addr add 10.0.0.1/30 dev ipip0
ip route add 192.168.2.0/24 via 10.0.0.2
```

##### **Клиент (192.168.2.1, внешний IP 2.2.2.2)**
```bash
ip tunnel add ipip0 mode ipip remote 1.1.1.1 local 2.2.2.2
ip link set ipip0 up
ip addr add 10.0.0.2/30 dev ipip0
ip route add 192.168.1.0/24 via 10.0.0.1
```

---

#### **GRE-туннель (Generic Routing Encapsulation)**
GRE может **инкапсулировать любые протоколы**, включая **IPv6 и нестандартные L3 протоколы**.

##### **Сервер (1.1.1.1)**
```bash
ip tunnel add gre0 mode gre remote 2.2.2.2 local 1.1.1.1 ttl 255
ip link set gre0 up
ip addr add 10.10.10.1/30 dev gre0
ip route add 192.168.2.0/24 via 10.10.10.2
```

##### **Клиент (2.2.2.2)**
```bash
ip tunnel add gre0 mode gre remote 1.1.1.1 local 2.2.2.2 ttl 255
ip link set gre0 up
ip addr add 10.10.10.2/30 dev gre0
ip route add 192.168.1.0/24 via 10.10.10.1
```

---

#### **SIT-туннель (IPv6-over-IPv4)**
Позволяет передавать **IPv6-трафик через IPv4**.

##### **Сервер (1.1.1.1)**
```bash
ip tunnel add sit0 mode sit remote 2.2.2.2 local 1.1.1.1 ttl 255
ip link set sit0 up
ip addr add 2001:db8::1/64 dev sit0
```

##### **Клиент (2.2.2.2)**
```bash
ip tunnel add sit0 mode sit remote 1.1.1.1 local 2.2.2.2 ttl 255
ip link set sit0 up
ip addr add 2001:db8::2/64 dev sit0
```

---

### **Настройка PPTP VPN**
PPTP (Point-to-Point Tunneling Protocol) – **устаревший, но простой VPN**, поддерживаемый Windows.

#### **Установка PPTP-сервера (Ubuntu/Debian)**
```bash
sudo apt install pptpd -y
```

#### **Настройка сервера (`/etc/pptpd.conf`)**
```ini
localip 192.168.100.1
remoteip 192.168.100.100-200
```

#### **Добавление пользователей (`/etc/ppp/chap-secrets`)**
```ini
user1 pptpd password *
```

#### **Включение IP-Forwarding**
```bash
echo 1 > /proc/sys/net/ipv4/ip_forward
```
Сохранение в `/etc/sysctl.conf`:
```ini
net.ipv4.ip_forward = 1
```

#### **Запуск PPTP**
```bash
systemctl restart pptpd
```

#### **Подключение к серверу**
```bash
sudo pptpsetup --create myvpn --server 1.1.1.1 --username user1 --password password --encrypt
pppd call myvpn
```

---

### **Настройка OpenVPN (SSL VPN)**
OpenVPN использует **SSL/TLS** для шифрования трафика.

#### **Установка OpenVPN**
```bash
sudo apt install openvpn -y
```

#### **Создание конфигурации сервера (`/etc/openvpn/server.conf`)**
```ini
port 1194
proto udp
dev tun
ca ca.crt
cert server.crt
key server.key
dh dh2048.pem
server 10.8.0.0 255.255.255.0
push "redirect-gateway def1"
cipher AES-256-CBC
keepalive 10 120
persist-key
persist-tun
```

#### **Запуск OpenVPN**
```bash
systemctl enable openvpn@server
systemctl start openvpn@server
```

#### **Подключение клиента**
```bash
openvpn --config client.ovpn
```

---

### **PPP+SSH VPN (SSH-туннель)**
Используется, когда **VPN запрещён, но доступен SSH**.

#### **Создание туннеля**
```bash
ssh -N -L 8080:localhost:8080 user@1.1.1.1
```
Клиент может подключаться через:
```bash
export http_proxy="http://localhost:8080"
```

---

### **Настройка IPsec (IPsec-tools)**
IPsec используется для **шифрованной передачи данных**.

#### **Установка IPsec (Ubuntu/Debian)**
```bash
sudo apt install strongswan -y
```

#### **Настройка `/etc/ipsec.conf`**
```ini
conn tunnel
    left=1.1.1.1
    leftsubnet=192.168.1.0/24
    right=2.2.2.2
    rightsubnet=192.168.2.0/24
    authby=secret
    auto=start
```

#### **Настройка ключа (`/etc/ipsec.secrets`)**
```ini
1.1.1.1 2.2.2.2 : PSK "secretpassword"
```

#### **Запуск IPsec**
```bash
systemctl restart strongswan
```

---

- **IPIP, GRE, SIT** – простые туннели для соединения сетей.
- **PPTP** – устаревший, но совместимый с Windows VPN.
- **OpenVPN** – надёжное шифрованное VPN с SSL/TLS.
- **PPP+SSH** – обход ограничений через SSH-туннель.
- **IPsec** – высокозащищённый VPN-стандарт.






#### **Критерии сравнения**  
| Метод | Шифрование | Совместимость | Сложность настройки | Производительность | Типичное применение |
|--------|-----------|--------------|--------------------|--------------------|---------------------|
| **IPIP (IP-over-IP)** | Нет | Linux, BSD | Простая | Высокая | Соединение двух IPv4-сетей без шифрования |
| **GRE (Generic Routing Encapsulation)** | Нет | Linux, BSD, Cisco | Простая | Высокая | Инкапсуляция L2/L3 протоколов, маршрутизируемые VPN |
| **SIT (IPv6-over-IPv4)** | Нет | Linux, BSD | Простая | Высокая | Передача IPv6 через IPv4-сети |
| **PPTP (Point-to-Point Tunneling Protocol)** | MPPE (128 бит) | Windows, Linux, Mac | Средняя | Средняя | Устаревший VPN, совместимость с Windows |
| **OpenVPN (SSL VPN)** | AES-256, TLS | Windows, Linux, Mac, Android, iOS | Средняя | Средняя | Универсальный VPN, подходит для корпоративного использования |
| **PPP+SSH (SSH-туннель)** | AES (SSH) | Windows, Linux, Mac | Средняя | Высокая | Обход блокировок, удалённый доступ через SSH |
| **IPsec (ESP/AH)** | AES-256, 3DES | Windows, Linux, Mac, Cisco | Высокая | Высокая | Корпоративный VPN, высокозащищённые туннели |

---

### **Детальный разбор способов**  

#### **1. IPIP, GRE, SIT – туннели без шифрования**  
- **Простые в настройке**, но **не защищают данные**.  
- Используются для **соединения двух сетей**, когда безопасность не является критичной.  
- **GRE** поддерживает **инкапсуляцию L2/L3** (например, OSPF через интернет).  
- **SIT** позволяет передавать **IPv6-трафик через IPv4-интернет**.

#### **2. PPTP – устаревший, но совместимый VPN**  
- **Лёгкость настройки** и поддержка в **Windows без дополнительных программ**.  
- Использует **MPPE (128-битное шифрование)**, но уязвим для атак.  
- **Подходит только для несовременных систем**.

#### **3. OpenVPN – надёжный SSL VPN**  
- **Использует SSL/TLS**, поддерживает **AES-256**.  
- **Хорошо работает за NAT и в сложных сетях**.  
- Совместим с **Windows, Linux, Mac, iOS, Android**.  
- **Рекомендуется для большинства VPN-сценариев**.

#### **4. PPP+SSH – SSH-туннель**  
- **Поддерживается везде, где есть SSH**.  
- **Удобен для обхода блокировок** и организации **удалённого доступа**.  
- **Не удобен для широкого использования**, но полезен в специфических задачах.

#### **5. IPsec – промышленный стандарт VPN**  
- **Высокая степень защиты (AES-256, 3DES, ESP/AH)**.  
- Поддерживается **Linux, Windows, Mac, Cisco**.  
- **Сложная настройка**, но **оптимальный выбор для корпоративных VPN**.  
- Используется для **безопасного соединения удалённых офисов**.

---


- **Для корпоративных решений** → **IPsec или OpenVPN**.  
- **Для простого VPN с кроссплатформенной поддержкой** → **OpenVPN**.  
- **Для связи сетей без шифрования** → **GRE или IPIP**.  
- **Для быстрого SSH-доступа** → **PPP+SSH**.  
- **Для Windows-клиентов без установки ПО** → **PPTP (но устарел и небезопасен)**.  




### **Установка FRR (Free Range Routing) в Linux**  

FRR (**Free Range Routing**) – это мощный маршрутизатор с поддержкой **BGP, OSPF, RIP, IS-IS, PIM и других протоколов**, используемый как альтернатива Quagga.

#### **Поддерживаемые платформы**  
FRR доступен для **Ubuntu, Debian, CentOS, AlmaLinux, Rocky Linux**.

---

### **Установка FRR на Ubuntu/Debian**
Добавляем официальный репозиторий:
```bash
sudo apt update
sudo apt install curl -y
curl -s https://deb.frrouting.org/frr/keys.asc | sudo apt-key add -
echo "deb https://deb.frrouting.org/frr $(lsb_release -sc) frr-stable" | sudo tee -a /etc/apt/sources.list.d/frr.list
sudo apt update
sudo apt install frr -y
```

---

### **Установка FRR на CentOS/AlmaLinux/Rocky**
Добавляем репозиторий:
```bash
sudo dnf install epel-release -y
sudo dnf config-manager --add-repo https://rpm.frrouting.org/frr/centos/frr.repo
sudo dnf install frr frr-pythontools -y
```

---

### **Запуск и включение FRR**
```bash
sudo systemctl enable frr
sudo systemctl start frr
```
Проверяем статус:
```bash
sudo systemctl status frr
```

---

### **Настройка FRR**
Редактируем файл `/etc/frr/daemons`, включаем нужные протоколы:
```ini
zebra=yes
bgpd=yes
ospfd=yes
ospf6d=no
ripd=no
ripngd=no
isisd=no
pimd=no
```
Применяем изменения:
```bash
sudo systemctl restart frr
```

---

### **Конфигурация через CLI (`vtysh`)**
Переходим в интерфейс управления:
```bash
sudo vtysh
```
Пример настройки BGP:
```bash
configure terminal
router bgp 65001
 neighbor 192.168.1.2 remote-as 65002
 network 10.0.0.0/24
exit
write memory
```
Пример настройки OSPF:
```bash
configure terminal
router ospf
 network 192.168.1.0/24 area 0
 network 10.0.0.0/8 area 0
exit
write memory
```

---

### **Проверка работы**
Проверяем маршрутизацию:
```bash
show ip route
```
Проверяем соседей BGP:
```bash
show ip bgp summary
```
Проверяем OSPF-соседей:
```bash
show ip ospf neighbor
```

---


- **FRR заменяет Quagga и поддерживает динамическую маршрутизацию (BGP, OSPF, RIP)**.  
- **Простая установка через репозитории**.  
- **Настройка через `vtysh` похожа на Cisco IOS**.  









`systemctl` — это утилита командной строки в Linux, которая используется для управления системой и сервисами в рамках системы инициализации **systemd**. Она позволяет запускать, останавливать, перезагружать, проверять статус, а также настраивать и управлять различными системными сервисами и процессами.

Основные функции `systemctl` включают управление сервисами, настройку автозапуска, проверку состояния, а также управление состоянием системы, такими как перезагрузка или выключение.

- Для запуска сервиса используется команда `sudo systemctl start <service>`.
- Для остановки сервиса — `sudo systemctl stop <service>`.
- Чтобы перезапустить сервис, можно использовать команду `sudo systemctl restart <service>`.
- Для проверки статуса сервиса применяется команда `sudo systemctl status <service>`.
- Для включения автозапуска сервиса на старте системы используется `sudo systemctl enable <service>`.
- Для отключения автозапуска — `sudo systemctl disable <service>`.

`systemctl` позволяет управлять состоянием системы, например, для выключения или перезагрузки системы используется `sudo systemctl poweroff` или `sudo systemctl reboot` соответственно.










Команда `systemctl` предоставляет множество подкоманд для управления системой и сервисами в рамках **systemd**. Вот описание некоторых из них:

- **add-requires** — добавляет зависимость для юнита.
- **add-wants** — добавляет запрос на зависимость для юнита.
- **bind** — связывает юнит с конкретным ресурсом.
- **cancel** — отменяет активные действия, такие как задание работы или зависимость.
- **cat** — выводит содержимое юнита или конфигурационного файла.
- **condreload** — выполняет перезагрузку юнита только при изменении его конфигурации.
- **condrestart** — перезапускает сервис только если он активен.
- **condstop** — останавливает сервис, если он активен.
- **daemon-reexec** — повторно выполняет процесс systemd, как если бы он был перезапущен.
- **daemon-reload** — перезагружает конфигурацию systemd.
- **disable** — отключает автозапуск юнита при старте системы.
- **edit** — открывает и редактирует конфигурационный файл юнита.
- **emergency** — переключает систему в аварийный режим.
- **enable** — включает автозапуск юнита при старте системы.
- **exit** — завершает текущую сессию `systemctl`.
- **force-reload** — принудительно перезагружает юнит.
- **freeze** — замораживает все процессы системы.
- **hibernate** — переводит систему в состояние гибернации.
- **help** — выводит справку по команде `systemctl`.
- **is-active** — проверяет, активен ли юнит.
- **is-enabled** — проверяет, включен ли автозапуск юнита.
- **is-failed** — проверяет, не завершился ли юнит с ошибкой.
- **is-system-running** — проверяет, работает ли система в нормальном режиме.
- **kill** — посылает сигнал для завершения процесса.
- **list-dependencies** — отображает зависимости для юнита.
- **list-jobs** — отображает текущие работы systemd.
- **list-machines** — отображает доступные виртуальные машины.
- **list-sockets** — выводит список активных сокетов.
- **list-timers** — показывает таймеры, запущенные в системе.
- **list-units** — выводит список всех юнитов.
- **list-unit-files** — выводит список всех файлов юнитов.
- **mask** — отключает юнит, запрещая его запуск.
- **poweroff** — выключает систему.
- **reboot** — перезагружает систему.
- **reload** — перезагружает конфигурацию юнита.
- **reload-or-restart** — перезагружает юнит, если он был изменен, или перезапускает его.
- **rescue** — переводит систему в режим восстановления.
- **restart** — перезапускает юнит.
- **show** — выводит подробную информацию о юните.
- **start** — запускает юнит.
- **stop** — останавливает юнит.
- **suspend** — приостанавливает работу системы.
- **thaw** — возобновляет работу системы после паузы.
- **unmask** — снимает блокировку с юнита.
- **whoami** — выводит имя пользователя, который управляет системой.


























### **Установка и использование `rinetd` – TCP-перенаправление портов**  

`rinetd` – это **простой TCP-прокси**, который перенаправляет трафик с одного IP-адреса и порта на другой. Полезен для проброса портов через сервер без сложных настроек NAT или VPN.

#### **Установка `rinetd`**
**Ubuntu/Debian**  
```bash
sudo apt update
sudo apt install rinetd -y
```
**CentOS/AlmaLinux/Rocky**  
```bash
sudo dnf install rinetd -y
```

---

### **Настройка `rinetd`**
Файл конфигурации:  
```bash
sudo nano /etc/rinetd.conf
```

Пример проброса **TCP 80 → 192.168.1.100:8080**:  
```ini
0.0.0.0 80 192.168.1.100 8080
```
Объяснение:  
- `0.0.0.0 80` – принимаем соединения на **все интерфейсы на порту 80**  
- `192.168.1.100 8080` – перенаправляем на **192.168.1.100:8080**  

---

### **Запуск и управление сервисом**
**Запуск `rinetd`**  
```bash
sudo systemctl start rinetd
sudo systemctl enable rinetd
```

**Перезапуск после изменений**  
```bash
sudo systemctl restart rinetd
```

**Проверка работы**  
```bash
sudo ss -tulnp | grep rinetd
```

---

### **Дополнительные параметры**
#### **Ограничение доступа (разрешённые IP)**
Добавляем разрешённый IP в `/etc/rinetd.conf`:  
```ini
0.0.0.0 22 192.168.1.100 22 allow 203.0.113.5
```
Только IP **203.0.113.5** сможет подключаться к проброшенному **SSH (22)**.

---

### **Проброс порта через публичный сервер**
Если **сервер имеет внешний IP**, можно использовать `rinetd` для проброса трафика:
```ini
0.0.0.0 443 10.0.0.2 443
```
Теперь **HTTPS-запросы на публичный сервер** будут уходить на **10.0.0.2**.

---

### **Остановка и удаление `rinetd`**
Остановка:
```bash
sudo systemctl stop rinetd
```
Удаление:
```bash
sudo apt remove --purge rinetd -y  # Debian/Ubuntu
sudo dnf remove rinetd -y          # CentOS/AlmaLinux
```

---

- **`rinetd` – простой и лёгкий TCP-перенаправитель**.  
- **Работает без сложных `iptables` или NAT**.  
- **Идеален для проброса портов и проксирования соединений**.  


### **Установка и использование `stunnel` – шифрованный TCP-туннель (TLS/SSL)**  

`stunnel` – это **прокси-сервер**, который добавляет **TLS/SSL-шифрование** для любых TCP-соединений. Используется для защиты нешифрованных сервисов (например, проброса HTTP, MySQL, VNC, SMTP через SSL).

---

### **Установка `stunnel`**
#### **Ubuntu/Debian**
```bash
sudo apt update
sudo apt install stunnel4 -y
```
#### **CentOS/AlmaLinux/Rocky**
```bash
sudo dnf install stunnel -y
```
Проверяем версию:
```bash
stunnel -version
```

---

### **Генерация SSL-сертификата (если нет)**
```bash
openssl req -new -x509 -days 365 -nodes -out /etc/stunnel/stunnel.pem -keyout /etc/stunnel/stunnel.pem
chmod 600 /etc/stunnel/stunnel.pem
```
Этот сертификат будет использоваться для шифрования.

---

### **Конфигурация `stunnel`**
Редактируем файл `/etc/stunnel/stunnel.conf`:
```bash
sudo nano /etc/stunnel/stunnel.conf
```
Пример: **Проброс порта MySQL (3306) через SSL**
```ini
[mysqls]
accept = 0.0.0.0:3307
connect = 127.0.0.1:3306
cert = /etc/stunnel/stunnel.pem
```
Объяснение:  
- **Принимаем соединения на `3307`**  
- **Пересылаем на `localhost:3306`**  
- **Используем SSL-сертификат**  

---

### **Запуск и включение `stunnel`**
#### **Ubuntu/Debian**
```bash
sudo systemctl restart stunnel4
sudo systemctl enable stunnel4
```
#### **CentOS/AlmaLinux**
```bash
sudo systemctl restart stunnel
sudo systemctl enable stunnel
```

---

### **Проверка работы**
Проверяем, слушает ли `stunnel` нужные порты:
```bash
ss -tulnp | grep stunnel
```
Должно отобразиться:
```
LISTEN  0  128  0.0.0.0:3307  0.0.0.0:*  users:(("stunnel",pid=xxx,fd=xxx))
```

---

### **Использование `stunnel` для SSH**
Создаём конфигурацию (`/etc/stunnel/stunnel.conf`):
```ini
[ssh]
accept = 443
connect = 127.0.0.1:22
cert = /etc/stunnel/stunnel.pem
```
Теперь SSH будет доступен через **порт 443 (обычно не блокируется в сетях)**.

Подключение с клиента:
```bash
stunnel -c -d 127.0.0.1:2222 -r remote.server.com:443
ssh -p 2222 localhost
```

---

### **Остановка и удаление `stunnel`**
Остановка:
```bash
sudo systemctl stop stunnel4
```
Удаление:
```bash
sudo apt remove --purge stunnel4 -y  # Debian/Ubuntu
sudo dnf remove stunnel -y           # CentOS/AlmaLinux
```

---

- **`stunnel` защищает нешифрованные сервисы с помощью TLS/SSL**.  
- **Простой в настройке, работает с MySQL, VNC, SSH, SMTP, HTTP**.  


