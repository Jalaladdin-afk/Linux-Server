### Установка Linux в виртуальной среде  
Выбирается дистрибутив, например, Ubuntu, Debian или AlmaLinux. Создаётся виртуальная машина, выделяется достаточно ресурсов, устанавливается система с ISO-образа, затем выполняется первый вход.

### Разовая настройка сети  
Сетевой интерфейс настраивается с помощью `ifconfig`:  
```bash
ifconfig eth0 192.168.1.100 netmask 255.255.255.0 up
```
Проверить настройки можно командой:  
```bash
ifconfig
```

### Настройка маршрутизации  
Для установки шлюза по умолчанию используется `route`:  
```bash
route add default gw 192.168.1.1 eth0
```
Просмотр таблицы маршрутов:  
```bash
route -n
```

### Настройка DNS  
Изменения в файле `/etc/resolv.conf`:  
```bash
echo "nameserver 8.8.8.8" > /etc/resolv.conf
echo "nameserver 1.1.1.1" >> /etc/resolv.conf
```
Проверка соединения:  
```bash
ping -c 4 google.com
```

Эти изменения действуют до перезагрузки. Чтобы сохранить их, нужно редактировать конфигурационные файлы системы.




### Настройка сети через `/etc/network/interfaces`  

Файл `/etc/network/interfaces` позволяет задавать постоянные сетевые настройки в Debian и Ubuntu.  

### Открытие файла для редактирования  
Редактировать файл можно с помощью `nano` или `vim`:  
```bash
sudo nano /etc/network/interfaces
```

### Настройка статического IP  
Для установки статического IP-адреса добавляется следующая конфигурация:  
```ini
auto eth0
iface eth0 inet static
    address 192.168.1.100
    netmask 255.255.255.0
    gateway 192.168.1.1
    dns-nameservers 8.8.8.8 1.1.1.1
```
Сетевой интерфейс `eth0` автоматически активируется при загрузке системы.

### Настройка DHCP  
Если требуется автоматическое получение IP-адреса от DHCP-сервера, конфигурация будет такой:  
```ini
auto eth0
iface eth0 inet dhcp
```

### Применение изменений  
После внесения изменений файл сохраняется, затем сеть перезапускается:  
```bash
sudo systemctl restart networking
```
Либо можно отключить и включить интерфейс:  
```bash
sudo ifdown eth0 && sudo ifup eth0
```

Проверить настройки можно с помощью:  
```bash
ip a
route -n
cat /etc/resolv.conf
```

После этих настроек сеть сохраняется даже после перезагрузки.







### Настройка сети с использованием Netplan  

Netplan используется в современных версиях Ubuntu (начиная с 17.10) для управления сетью. Конфигурация выполняется через файлы `.yaml`, расположенные в `/etc/netplan/`.  

### Открытие файла конфигурации  
Файл конфигурации сети обычно находится в `/etc/netplan/`. Его можно открыть в редакторе:  
```bash
sudo nano /etc/netplan/01-netcfg.yaml
```
Если такого файла нет, можно создать новый.  

### Настройка статического IP  
Для задания статического IP-адреса конфигурация будет следующей:  
```yaml
network:
  version: 2
  renderer: networkd
  ethernets:
    eth0:
      dhcp4: no
      addresses:
        - 192.168.1.100/24
      gateway4: 192.168.1.1
      nameservers:
        addresses:
          - 8.8.8.8
          - 1.1.1.1
```
После редактирования файл сохраняется.  

### Настройка DHCP  
Если требуется автоматическое получение IP-адреса от DHCP-сервера, используется следующий вариант:  
```yaml
network:
  version: 2
  renderer: networkd
  ethernets:
    eth0:
      dhcp4: yes
```

### Применение настроек  
После изменения конфигурации необходимо применить её командой:  

```bash

sudo netplan try


sudo netplan apply
```
Для проверки текущих сетевых настроек можно использовать:  
```bash
ip a
ip route
cat /etc/resolv.conf
```

Настройки, выполненные через Netplan, сохраняются и работают после перезагрузки системы.







### **Настройка сети в дистрибутивах Linux на базе Red Hat**  

NetworkManager является основным инструментом для управления сетью в современных версиях RHEL, CentOS, AlmaLinux и Rocky Linux. Он позволяет настраивать сеть через командную строку, текстовый интерфейс или конфигурационные файлы.  

### **Настройка через `nmcli`**  
Сетевые интерфейсы можно просмотреть с помощью `nmcli device status`. Для настройки статического IP-адреса используются команды:  
```bash
nmcli con mod eth0 ipv4.addresses 192.168.1.100/24
nmcli con mod eth0 ipv4.gateway 192.168.1.1
nmcli con mod eth0 ipv4.dns 8.8.8.8
nmcli con mod eth0 ipv4.method manual
nmcli con up eth0
```
Если требуется включить DHCP, можно изменить метод получения IP:  
```bash
nmcli con mod eth0 ipv4.method auto
nmcli con up eth0
```
Сеть можно перезагрузить командой:  
```bash
nmcli networking off && nmcli networking on
```

### **Настройка через `nmtui`**  
Для удобной текстовой конфигурации сети запускается `nmtui`. В интерфейсе можно изменить параметры подключения, сохранить изменения и перезапустить сеть.

### **Настройка через файлы конфигурации**  
В дистрибутивах до RHEL 8 файлы сетевых настроек находятся в `/etc/sysconfig/network-scripts/`.  
Для настройки интерфейса создаётся или редактируется файл `/etc/sysconfig/network-scripts/ifcfg-eth0`:  
```ini
DEVICE=eth0
BOOTPROTO=static
ONBOOT=yes
IPADDR=192.168.1.100
NETMASK=255.255.255.0
GATEWAY=192.168.1.1
DNS1=8.8.8.8
```
После внесения изменений сеть перезапускается:  
```bash
sudo systemctl restart network
```

### **Временная настройка через `ifconfig` и `route`**  
Эти команды позволяют настроить сеть, но изменения не сохраняются после перезагрузки.  
Для назначения IP-адреса используется:  
```bash
ifconfig eth0 192.168.1.100 netmask 255.255.255.0 up
```
Шлюз по умолчанию задаётся через `route`:  
```bash
route add default gw 192.168.1.1 eth0
```
DNS-сервер добавляется в файл `/etc/resolv.conf`:  
```bash
echo "nameserver 8.8.8.8" > /etc/resolv.conf
```








### Настройка Wi-Fi с консоли в Linux  

Wi-Fi в консоли можно настроить разными способами в зависимости от дистрибутива и утилит. Ниже рассмотрены основные методы.

---

### Проверка наличия Wi-Fi-адаптера  
Для начала проверяется, доступен ли Wi-Fi-адаптер в системе:  
```bash
iwconfig
```
Если интерфейс Wi-Fi (`wlan0` или другой) отсутствует, можно проверить его состояние:  
```bash
ip link show wlan0
```
Если интерфейс `DOWN`, его можно включить:  
```bash
sudo ip link set wlan0 up
```

---

### Подключение через `nmcli` (NetworkManager)  
Если используется **NetworkManager**, подключиться к Wi-Fi можно командой:  
```bash
sudo nmcli device wifi list
```
После нахождения нужной сети выполняется подключение:  
```bash
sudo nmcli device wifi connect "SSID" password "пароль"
```
Проверка состояния подключения:  
```bash
nmcli connection show
```

---

### Подключение через `wpa_supplicant`  
Для систем без NetworkManager можно использовать `wpa_supplicant`.  

1. Создаётся файл конфигурации Wi-Fi:  
```bash
wpa_passphrase "SSID" "пароль" | sudo tee /etc/wpa_supplicant.conf
```
2. Подключение к сети:  
```bash
sudo wpa_supplicant -B -i wlan0 -c /etc/wpa_supplicant.conf
```
3. Получение IP-адреса через DHCP:  
```bash
sudo dhclient wlan0
```
4. Проверка подключения:  
```bash
ip a show wlan0
ping -c 4 google.com
```

---

### Настройка через Netplan  
Для современных систем, использующих Netplan, Wi-Fi настраивается в файле `/etc/netplan/01-netcfg.yaml`:  
```yaml
network:
  version: 2
  renderer: networkd
  wifis:
    wlan0:
      access-points:
        "SSID":
          password: "пароль"
      dhcp4: true
```
После редактирования файл сохраняется, затем изменения применяются:  
```bash
sudo netplan apply
```

---

### Автоматическое подключение при загрузке  
Для автоматического подключения можно добавить Wi-Fi-сеть в `wpa_supplicant.conf`:  
```bash
sudo nano /etc/wpa_supplicant/wpa_supplicant.conf
```
Добавляется блок:  
```ini
network={
    ssid="SSID"
    psk="пароль"
    key_mgmt=WPA-PSK
}
```
Сохранённые изменения применяются:  
```bash
sudo systemctl restart wpa_supplicant
```

---

### Проверка состояния соединения  
После подключения можно проверить соединение:  
```bash
iwconfig wlan0
nmcli device status
ping -c 4 google.com
```
Эти методы позволяют подключить Wi-Fi в Linux без использования графического интерфейса.









### Изменение имени хоста и настройка файлов `/etc/hosts` и `/etc/hostname`

**Имя хоста (hostname)** — это уникальное имя компьютера в сети, которое используется для его идентификации. В Linux оно хранится в файле `/etc/hostname` и может быть сопоставлено с IP-адресами в `/etc/hosts`.

---

### Проверка текущего имени хоста  
Чтобы узнать текущее имя хоста, используется команда:  
```bash
hostname
```
Либо:  
```bash
cat /etc/hostname
```

---

### Временное изменение имени хоста  
Можно изменить имя хоста до перезагрузки:  
```bash
sudo hostnamectl set-hostname new-hostname
```
Проверка изменений:  
```bash
hostnamectl
```

Если система не поддерживает `hostnamectl`, можно использовать команду:  
```bash
sudo hostname new-hostname
```
Но это изменение действует только до перезагрузки.

---

### Постоянное изменение имени хоста  

1. Открывается файл `/etc/hostname`:  
```bash
sudo nano /etc/hostname
```
2. Старое имя заменяется на новое, затем файл сохраняется.  

---

### Настройка `/etc/hosts`  
Файл `/etc/hosts` связывает IP-адреса с именами хостов. После изменения имени хоста необходимо обновить этот файл:  
```bash
sudo nano /etc/hosts
```
Здесь должен быть такой формат:  
```ini
127.0.0.1   localhost
127.0.1.1   new-hostname
```
`127.0.1.1` используется для локального имени хоста.

---

### Применение изменений  
После внесения изменений сервис `hostname` можно перезапустить:  
```bash
sudo systemctl restart systemd-hostnamed
```
Или перезагрузить систему:  
```bash
sudo reboot
```
Проверить, применились ли изменения, можно командами:  
```bash
hostname
hostnamectl
cat /etc/hostname
```
Настроенные файлы `/etc/hosts` и `/etc/hostname` обеспечивают правильную работу имени хоста в сети и локально.





### Установка OpenSSH сервера, генерация ключей и настройка конфигурации  

OpenSSH — это набор инструментов для работы с SSH, который обеспечивает безопасное удалённое управление сервером.  

---

### Установка OpenSSH сервера  
В зависимости от дистрибутива установка выполняется следующими командами:  

**Ubuntu / Debian:**  
```bash
sudo apt update
sudo apt install openssh-server -y
```
**AlmaLinux / CentOS / RHEL:**  
```bash
sudo dnf install -y openssh-server
```

После установки OpenSSH включается и запускается:  
```bash
sudo systemctl enable --now ssh
```
Проверить статус можно командой:  
```bash
sudo systemctl status ssh
```

---

### Генерация ключей SSH  
При установке OpenSSH сервер автоматически создаёт ключи, которые хранятся в каталоге:  
```bash
ls -l /etc/ssh/
```
Обычно используются следующие файлы:  
- `/etc/ssh/ssh_host_rsa_key` – закрытый ключ RSA  
- `/etc/ssh/ssh_host_rsa_key.pub` – открытый ключ RSA  
- `/etc/ssh/ssh_host_ecdsa_key` – закрытый ключ ECDSA  
- `/etc/ssh/ssh_host_ed25519_key` – закрытый ключ ED25519  

Эти ключи используются сервером для установления зашифрованного соединения.

Если необходимо сгенерировать новый набор ключей, можно использовать команду:  
```bash
sudo ssh-keygen -A
```

---

### Базовая конфигурация OpenSSH сервера (`/etc/ssh/sshd_config`)  
Основной конфигурационный файл OpenSSH сервера — `/etc/ssh/sshd_config`.  

Открывается для редактирования:  
```bash
sudo nano /etc/ssh/sshd_config
```

**Основные параметры:**  
- **Порт подключения (по умолчанию 22, можно изменить для безопасности)**  
  ```ini
  Port 22
  ```
- **Запрет входа под root (рекомендуется отключить для безопасности)**  
  ```ini
  PermitRootLogin no
  ```
- **Разрешение входа только по ключам (для повышения безопасности)**  
  ```ini
  PasswordAuthentication no
  PubkeyAuthentication yes
  ```
- **Настройка списка разрешённых пользователей**  
  ```ini
  AllowUsers user1 user2
  ```
- **Отключение SSH для определённых пользователей**  
  ```ini
  DenyUsers root test
  ```
После внесения изменений конфигурация перезагружается:  
```bash
sudo systemctl restart ssh
```

---

### Проверка работы OpenSSH сервера  
Для проверки удалённого подключения можно выполнить:  
```bash
ssh user@server-ip
```
Если аутентификация по паролю отключена, необходимо предварительно скопировать SSH-ключи:  
```bash
ssh-copy-id user@server-ip
```

Настроенный OpenSSH сервер позволяет безопасно управлять системой удалённо.







### Указание списка хостов, с которых разрешено подключение с использованием конкретного открытого ключа  

В OpenSSH можно ограничить доступ для конкретных ключей SSH в файле `~/.ssh/authorized_keys`, используя директиву `from="список_хостов"`. Это позволяет разрешить аутентификацию только с определённых IP-адресов или доменов.  

---

### Настройка ограничения по хостам в `authorized_keys`  

1. Открывается файл `~/.ssh/authorized_keys`:  
   ```bash
   nano ~/.ssh/authorized_keys
   ```
2. Перед ключом добавляется директива `from="список_хостов"`, например:  
   ```ini
   from="192.168.1.100" ssh-rsa AAAAB3... пользователь@хост
   ```
   В этом случае доступ будет разрешён только с IP-адреса `192.168.1.100`.  

3. Если нужно разрешить несколько IP-адресов или домены, они указываются через запятую:  
   ```ini
   from="192.168.1.100,192.168.1.101,example.com" ssh-rsa AAAAB3... пользователь@хост
   ```
   Можно использовать маски подсетей:  
   ```ini
   from="192.168.1.*" ssh-rsa AAAAB3... пользователь@хост
   ```

4. После внесения изменений файл сохраняется и закрывается.  

---

### Проверка и тестирование  
После настройки можно попытаться подключиться с разных хостов, чтобы проверить, что доступ разрешён только с указанных адресов.  

Команда для тестирования подключения:  
```bash
ssh user@server-ip
```
Если подключение происходит с запрещённого IP-адреса, сервер SSH отклонит попытку входа.  

Дополнительно можно проверить лог SSH для диагностики:  
```bash
sudo journalctl -u ssh --no-pager | grep "authentication failure"
```

Использование директивы `from="..."` в `authorized_keys` повышает безопасность, ограничивая вход по ключу только с определённых устройств или сетей.






### Ограничение команд для конкретного SSH-ключа  

В OpenSSH можно ограничить список команд, которые разрешено выполнять при подключении по конкретному SSH-ключу. Это делается с помощью директивы `command="..."` в файле `~/.ssh/authorized_keys`.  

---

### Настройка ограниченных команд  

1. Открывается файл `~/.ssh/authorized_keys`:  
   ```bash
   nano ~/.ssh/authorized_keys
   ```
2. Перед ключом добавляется `command="команда"`, например:  
   ```ini
   command="/usr/bin/uptime" ssh-rsa AAAAB3... пользователь@хост
   ```
   В этом случае при подключении по данному ключу будет выполнена только команда `uptime`, после чего соединение закроется.

3. Можно разрешить выполнение только определённого скрипта:  
   ```ini
   command="/home/user/scripts/backup.sh" ssh-rsa AAAAB3... пользователь@хост
   ```
   Это полезно, если нужно разрешить запуск только резервного копирования или других задач.

4. Чтобы запретить открытие интерактивного сеанса и ограничить доступ только до определённой команды, можно комбинировать `command` с `restrict`:  
   ```ini
   command="/home/user/scripts/logs.sh",restrict ssh-rsa AAAAB3... пользователь@хост
   ```

---

### Дополнительные ограничения  

Для ещё большей безопасности можно комбинировать `command` с другими параметрами:  

- **Запрет перенаправления портов, X11, прокси-агента и оболочки:**  
  ```ini
  command="/home/user/scripts/status.sh",no-agent-forwarding,no-port-forwarding,no-X11-forwarding,no-pty ssh-rsa AAAAB3... пользователь@хост
  ```
  В этом случае пользователь не сможет перенаправлять порты, использовать X11 и получать доступ к интерактивному терминалу.

- **Ограничение для нескольких ключей**  
  Можно задать разные команды для разных ключей, если у пользователя несколько SSH-ключей.

---

### Проверка настройки  
После внесения изменений в `authorized_keys` можно протестировать подключение:  
```bash
ssh user@server-ip
```
Если всё настроено правильно, доступ к оболочке будет запрещён, и выполнится только указанная команда.

Настройка ограничений для SSH-ключей помогает повысить безопасность и контролировать доступ к серверу.






### Настройка автообновления системы с помощью `unattended-upgrades`

`unattended-upgrades` — это сервис в Debian, Ubuntu и их производных, который автоматически устанавливает обновления безопасности и системные пакеты без участия пользователя.

---

### Установка `unattended-upgrades`  

Если пакет не установлен, его можно установить вручную:  
```bash
sudo apt update
sudo apt install unattended-upgrades -y
```
После установки сервис включается автоматически.

---

### Настройка `/etc/apt/apt.conf.d/50unattended-upgrades`  

Основной конфигурационный файл `unattended-upgrades` находится по пути:  
```bash
sudo nano /etc/apt/apt.conf.d/50unattended-upgrades
```
В нём можно указать, какие пакеты обновлять. По умолчанию включены обновления безопасности:  
```ini
Unattended-Upgrade::Allowed-Origins {
    "origin=Debian,codename=${distro_codename},label=Debian-Security";
    "origin=Ubuntu,codename=${distro_codename},label=Ubuntu-Security";
};
```
Чтобы разрешить установку всех обновлений, можно добавить:  
```ini
    "origin=Debian,codename=${distro_codename},label=Debian";
    "origin=Ubuntu,codename=${distro_codename},label=Ubuntu";
```

Для автоматического удаления устаревших пакетов:  
```ini
Unattended-Upgrade::Remove-Unused-Dependencies "true";
```

---

### Включение автоматического обновления  

Файл `/etc/apt/apt.conf.d/20auto-upgrades` настраивает поведение системы при обновлениях. Если его нет, создаётся новый:  
```bash
sudo nano /etc/apt/apt.conf.d/20auto-upgrades
```
Добавляются строки:  
```ini
APT::Periodic::Update-Package-Lists "1";
APT::Periodic::Unattended-Upgrade "1";
```
Где:  
- `1` — означает включение автообновлений.

---

### Проверка и тестирование  

Чтобы проверить, какие обновления будут установлены, используется команда:  
```bash
sudo unattended-upgrade --dry-run
```
Принудительный запуск обновлений вручную:  
```bash
sudo unattended-upgrade -d
```
Проверить логи можно командой:  
```bash
cat /var/log/unattended-upgrades/unattended-upgrades.log
```

---

### Отключение автоматического обновления  

Если автообновления не нужны, их можно отключить:  
```bash
sudo systemctl stop unattended-upgrades
sudo systemctl disable unattended-upgrades
```
Или изменить конфигурацию `/etc/apt/apt.conf.d/20auto-upgrades`, установив `0` вместо `1`.

Настроенный `unattended-upgrades` позволяет автоматизировать процесс обновлений, повышая безопасность и стабильность системы.





### Настройка ротации логов с помощью `logrotate`  

`logrotate` – это утилита, которая автоматически управляет лог-файлами: ограничивает их размер, удаляет старые записи и архивирует их.  

---

### Проверка установки `logrotate`  

Обычно `logrotate` предустановлен в большинстве дистрибутивов. Чтобы проверить, установлен ли он:  
```bash
logrotate --version
```
Если не установлен, можно установить вручную:  

**Ubuntu / Debian:**  
```bash
sudo apt update
sudo apt install logrotate -y
```
**AlmaLinux / CentOS / RHEL:**  
```bash
sudo dnf install logrotate -y
```

---

### Основные конфигурационные файлы  

- **Глобальная конфигурация:** `/etc/logrotate.conf`  
- **Индивидуальные настройки для сервисов:** `/etc/logrotate.d/`  

Файл `/etc/logrotate.conf` задаёт основные параметры, а в `/etc/logrotate.d/` находятся настройки ротации для отдельных сервисов (например, `nginx`, `syslog`, `apache2`).

---

### Настройка ротации логов  

Пример базовой конфигурации в `/etc/logrotate.conf`:  
```ini
# Проверять ротацию логов раз в день
daily

# Хранить 7 архивных копий
rotate 7

# Сжимать старые логи
compress

# Создавать новый лог после ротации
create

# Если лог пустой, не ротировать
notifempty

# Применять ко всем логам
include /etc/logrotate.d/
```

---

### Создание правила ротации для конкретного лога  

Например, для ротации логов `/var/log/custom.log` создаётся файл:  
```bash
sudo nano /etc/logrotate.d/custom
```
Пример содержимого:  
```ini
/var/log/custom.log {
    weekly        # Ротация раз в неделю
    rotate 4      # Хранить 4 старых файла
    compress      # Сжимать файлы
    missingok     # Не выводить ошибку, если лог отсутствует
    notifempty    # Пропускать, если лог пуст
    create 640 root adm  # Создавать новый файл с правами
    postrotate
        systemctl restart custom-service  # Команда после ротации
    endscript
}
```

---

### Проверка работы `logrotate`  

Проверить конфигурацию перед применением:  
```bash
sudo logrotate -d /etc/logrotate.conf
```
Принудительно выполнить ротацию логов:  
```bash
sudo logrotate -f /etc/logrotate.conf
```
Проверить созданные архивные файлы:  
```bash
ls -lh /var/log/
```

`logrotate` позволяет автоматически управлять логами, предотвращая их переполнение и обеспечивая удобное хранение.




### Методы клонирования и переноса системы  

Клонирование системы может выполняться несколькими методами:  
- Полный перенос диска (образа) с помощью `dd`  
- Перенос только файлов с резервным копированием и восстановлением на новом сервере  

---

### **Полное клонирование диска с помощью `dd`**  

Утилита `dd` создаёт точную копию диска или раздела, включая загрузчик и файловую систему.  

#### **Клонирование всего диска**  
Перед началом работы следует определить имена дисков:  
```bash
lsblk
```
Для копирования всего диска `/dev/sda` на `/dev/sdb`:  
```bash
sudo dd if=/dev/sda of=/dev/sdb bs=4M status=progress
```
Где:  
- `if=/dev/sda` – источник  
- `of=/dev/sdb` – целевой диск  
- `bs=4M` – размер блока (увеличивает скорость)  
- `status=progress` – отображает ход выполнения  

После завершения клонирования желательно обновить `UUID` диска:  
```bash
sudo blkid
sudo tune2fs -U random /dev/sdb1
```
Это необходимо, чтобы избежать конфликтов при загрузке.

#### **Создание и восстановление образа диска**  
Если диск нужно сохранить в файл:  
```bash
sudo dd if=/dev/sda of=/mnt/backup/disk_image.img bs=4M status=progress
```
Восстановление выполняется командой:  
```bash
sudo dd if=/mnt/backup/disk_image.img of=/dev/sdb bs=4M status=progress
```

#### **Клонирование только одного раздела**  
Если нужно клонировать только системный раздел (`/dev/sda1`), используется:  
```bash
sudo dd if=/dev/sda1 of=/dev/sdb1 bs=4M status=progress
```
Затем требуется обновить `grub`:  
```bash
sudo grub-install /dev/sdb
sudo update-grub
```

---

### **Перенос системы с резервным копированием и восстановлением**  

Если не требуется копирование всего диска, можно использовать резервное копирование файлов.

#### **Создание резервной копии с `rsync`**  
Команда `rsync` позволяет копировать систему без сохранения ненужных данных, например, виртуальных файловых систем (`/proc`, `/sys`, `/dev`).  
```bash
sudo rsync -aAXv /* /mnt/backup --exclude={"/dev/*","/proc/*","/sys/*","/tmp/*","/run/*","/mnt/*","/media/*","/lost+found"}
```
Где:  
- `-aAX` – сохраняются права, ссылки, владельцы  
- `--exclude={}` – исключение временных директорий  

#### **Восстановление на новом сервере**  
На новом сервере выполняется разворачивание:  
```bash
sudo rsync -aAXv /mnt/backup/ /
```
После восстановления требуется:  
- Обновить `fstab`:  
  ```bash
  sudo nano /etc/fstab
  ```
- Установить загрузчик:  
  ```bash
  sudo grub-install /dev/sda
  sudo update-grub
  ```

---

### **Выбор метода клонирования**  
| Метод | Преимущества | Недостатки |
|--------|--------------|--------------|
| `dd` (полное клонирование) | Полный перенос системы, включая загрузчик, MBR, разделы | Долгое копирование, копирует пустое пространство |
| `rsync` (копирование файлов) | Гибкость, перенос только нужных файлов, можно исключать каталоги | Требуется настройка загрузчика и `fstab` вручную |

Оба метода подходят для миграции системы, но `dd` лучше использовать при необходимости полного клонирования, а `rsync` – для переносов без ненужных данных.







