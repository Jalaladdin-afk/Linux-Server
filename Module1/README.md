### Установка Linux в виртуальной среде  

Выбирается дистрибутив, например, Ubuntu, Debian или AlmaLinux. Создаётся виртуальная машина, выделяется достаточно ресурсов, устанавливается система с ISO-образа, затем выполняется первый вход.





Команда `setterm` в Linux используется для настройки различных параметров терминала, таких как цвет текста, очистка экрана и другие поведенческие характеристики терминала. Она позволяет настраивать внешний вид и поведение терминала в течение текущей сессии.

Вот общая форма использования команды `setterm`:

```
setterm [ОПЦИЯ] [ЗНАЧЕНИЕ]
```

### Изменение цвета текста
Вы можете изменить цвет текста в терминале с помощью опций `-foreground` (или `-fg`) и `-background` (или `-bg`).

Пример: изменить цвет текста на зелёный:
```bash
setterm -foreground green
```

Изменить цвет фона на синий:
```bash
setterm -background blue
```

### Очистка экрана
Чтобы очистить экран терминала, используйте опцию `-clear`.

Пример:
```bash
setterm -clear
```

### Эффекты текста
Команда `setterm` позволяет применить различные эффекты к тексту, такие как жирный, подчёркнутый и инвертированный (меняет цвета текста и фона местами).

Пример: сделать текст жирным:
```bash
setterm -bold on
```

Пример: выключить жирный текст:
```bash
setterm -bold off
```

Пример: включить подчёркивание текста:
```bash
setterm -underline on
```

Пример: выключить подчёркивание:
```bash
setterm -underline off
```

### Настройка времени для выключения экрана
Вы можете настроить, чтобы экран терминала автоматически выключался (становился чёрным) через указанное количество секунд.

Пример: выключить экран через 10 секунд:
```bash
setterm -blank 10
```

Пример: отключить автоматическое выключение экрана:
```bash
setterm -blank 0
```

### Поведение курсора
Вы можете управлять видимостью и поведением курсора.

Пример: скрыть курсор:
```bash
setterm -cursor off
```

Пример: показать курсор:
```bash
setterm -cursor on
```

### Настройка разрешения экрана
Вы можете изменить разрешение терминала (не всегда работает, зависит от терминала).

Пример: установить разрешение экрана 80x25 символов (по умолчанию):
```bash
setterm -cols 80 -rows 25
```

### Сброс всех настроек
Чтобы сбросить все настройки терминала в значения по умолчанию:
```bash
setterm -reset
```

### Пример нескольких опций:
Вы можете комбинировать несколько опций в одной команде. Например, чтобы изменить цвет текста на красный, фон на жёлтый и сделать текст жирным:
```bash
setterm -foreground red -background yellow -bold on
```

### Справка
Чтобы получить больше информации обо всех доступных опциях, можно выполнить команду:
```bash
man setterm
```

Или:
```bash
setterm --help
```

Это даст вам подробный список всех доступных опций и их применения.

### Примечание:
`setterm` работает с виртуальными терминалами (TTY), но может не работать должным образом в терминальных эмуляторах, таких как GNOME Terminal, Konsole или xterm, поскольку у этих программ есть свои методы настройки внешнего вида.










### Настройка маршрутизации  
Для установки шлюза по умолчанию используется `route`:  
```bash
route add default gw 192.168.1.1 eth0
```
Просмотр таблицы маршрутов:  
```bash
route -n
```

### Настройка DNS  
Изменения в файле `/etc/resolv.conf`:  
```bash
echo "nameserver 8.8.8.8" > /etc/resolv.conf
echo "nameserver 1.1.1.1" >> /etc/resolv.conf
```
Проверка соединения:  
```bash
ping -c 4 google.com
```

Эти изменения действуют до перезагрузки. Чтобы сохранить их, нужно редактировать конфигурационные файлы системы.






Для создания конфигурационного файла для **Netplan** с использованием DHCP с помощью команды **`cat`**, выполните следующие шаги:

### 1. **Создание конфигурации Netplan с DHCP с использованием `cat`**

1. Откройте терминал и выполните следующую команду для создания конфигурационного файла:

   ```bash
   sudo cat > /etc/netplan/01-netcfg.yaml <<EOF
   network:
     version: 2
     renderer: networkd
     ethernets:
       eth0:
         dhcp4: true
   EOF
   ```

### Объяснение:
- **`sudo cat > /etc/netplan/01-netcfg.yaml`** — эта команда создаёт или перезаписывает файл `01-netcfg.yaml` в каталоге `/etc/netplan/`.
- **`<<EOF`** — это специальный синтаксис для ввода многострочного текста в командной строке. Всё, что вы пишете после этого до `EOF`, будет записано в файл.
- **network: version: 2 renderer: networkd ethernets: eth0: dhcp4: true** — это сама конфигурация, которая указывает, что для интерфейса `eth0` будет использоваться DHCP для получения IP-адреса.

### 2. **Применение конфигурации**

После того как конфигурация записана, примените изменения с помощью команды:

```bash
sudo netplan apply
```

### 3. **Проверка подключения**

Чтобы проверить, что интерфейс подключен и получил IP-адрес через DHCP, используйте команду:

```bash
ip a
```








### Настройка сети через `/etc/network/interfaces`  

Файл `/etc/network/interfaces` позволяет задавать постоянные сетевые настройки в Debian и Ubuntu.  

### Открытие файла для редактирования  
Редактировать файл можно с помощью `nano` или `vim`:  
```bash
sudo nano /etc/network/interfaces
```

### Настройка статического IP  
Для установки статического IP-адреса добавляется следующая конфигурация:  
```ini
auto eth0
iface eth0 inet static
    address 192.168.1.100
    netmask 255.255.255.0
    gateway 192.168.1.1
    dns-nameservers 8.8.8.8 1.1.1.1
```
Сетевой интерфейс `eth0` автоматически активируется при загрузке системы.

### Настройка DHCP  
Если требуется автоматическое получение IP-адреса от DHCP-сервера, конфигурация будет такой:  
```ini
auto eth0
iface eth0 inet dhcp
```

### Применение изменений  
После внесения изменений файл сохраняется, затем сеть перезапускается:  
```bash
sudo systemctl restart networking
```
Либо можно отключить и включить интерфейс:  
```bash
sudo ifdown eth0 && sudo ifup eth0
```

Проверить настройки можно с помощью:  
```bash
ip a
route -n
cat /etc/resolv.conf
```

После этих настроек сеть сохраняется даже после перезагрузки.







### Настройка сети с использованием Netplan  

Netplan используется в современных версиях Ubuntu (начиная с 17.10) для управления сетью. Конфигурация выполняется через файлы `.yaml`, расположенные в `/etc/netplan/`.  

### Открытие файла конфигурации  
Файл конфигурации сети обычно находится в `/etc/netplan/`. Его можно открыть в редакторе:  
```bash
sudo nano /etc/netplan/01-netcfg.yaml
```
Если такого файла нет, можно создать новый.  

### Настройка статического IP  
Для задания статического IP-адреса конфигурация будет следующей:  
```yaml
network:
  version: 2
  renderer: networkd
  ethernets:
    eth0:
      dhcp4: no
      addresses:
        - 192.168.1.100/24
      gateway4: 192.168.1.1
      nameservers:
        addresses:
          - 8.8.8.8
          - 1.1.1.1
```
После редактирования файл сохраняется.  

### Настройка DHCP  
Если требуется автоматическое получение IP-адреса от DHCP-сервера, используется следующий вариант:  
```yaml
network:
  version: 2
  renderer: networkd
  ethernets:
    eth0:
      dhcp4: yes
```

### Применение настроек  
После изменения конфигурации необходимо применить её командой:  

```bash

sudo netplan try


sudo netplan apply
```
Для проверки текущих сетевых настроек можно использовать:  
```bash
ip a
ip route
cat /etc/resolv.conf
```








### **Настройка сети в дистрибутивах Linux на базе Red Hat**  

NetworkManager является основным инструментом для управления сетью в современных версиях RHEL, CentOS, AlmaLinux и Rocky Linux. Он позволяет настраивать сеть через командную строку, текстовый интерфейс или конфигурационные файлы.  

### **Настройка через `nmcli`**  
Сетевые интерфейсы можно просмотреть с помощью `nmcli device status`. Для настройки статического IP-адреса используются команды:  
```bash
nmcli con mod eth0 ipv4.addresses 192.168.1.100/24
nmcli con mod eth0 ipv4.gateway 192.168.1.1
nmcli con mod eth0 ipv4.dns 8.8.8.8
nmcli con mod eth0 ipv4.method manual
nmcli con up eth0
```
Если требуется включить DHCP, можно изменить метод получения IP:  
```bash
nmcli con mod eth0 ipv4.method auto
nmcli con up eth0
```
Сеть можно перезагрузить командой:  
```bash
nmcli networking off && nmcli networking on
```

### **Настройка через `nmtui`**  
Для удобной текстовой конфигурации сети запускается `nmtui`. В интерфейсе можно изменить параметры подключения, сохранить изменения и перезапустить сеть.

### **Настройка через файлы конфигурации**  
В дистрибутивах до RHEL 8 файлы сетевых настроек находятся в `/etc/sysconfig/network-scripts/`.  
Для настройки интерфейса создаётся или редактируется файл `/etc/sysconfig/network-scripts/ifcfg-eth0`:  
```ini
DEVICE=eth0
BOOTPROTO=static
ONBOOT=yes
IPADDR=192.168.1.100
NETMASK=255.255.255.0
GATEWAY=192.168.1.1
DNS1=8.8.8.8
```
После внесения изменений сеть перезапускается:  
```bash
sudo systemctl restart network
```

### **Временная настройка через `ifconfig` и `route`**  
Эти команды позволяют настроить сеть, но изменения не сохраняются после перезагрузки.  
Для назначения IP-адреса используется:  
```bash
ifconfig eth0 192.168.1.100 netmask 255.255.255.0 up
```
Шлюз по умолчанию задаётся через `route`:  
```bash
route add default gw 192.168.1.1 eth0
```
DNS-сервер добавляется в файл `/etc/resolv.conf`:  
```bash
echo "nameserver 8.8.8.8" > /etc/resolv.conf
```








### Настройка Wi-Fi с консоли в Linux  

Wi-Fi в консоли можно настроить разными способами в зависимости от дистрибутива и утилит. Ниже рассмотрены основные методы.

---

### Проверка наличия Wi-Fi-адаптера  
Для начала проверяется, доступен ли Wi-Fi-адаптер в системе:  
```bash
iwconfig
```
Если интерфейс Wi-Fi (`wlan0` или другой) отсутствует, можно проверить его состояние:  
```bash
ip link show wlan0
```
Если интерфейс `DOWN`, его можно включить:  
```bash
sudo ip link set wlan0 up
```

---

### Подключение через `nmcli` (NetworkManager)  
Если используется **NetworkManager**, подключиться к Wi-Fi можно командой:  
```bash
sudo nmcli device wifi list
```
После нахождения нужной сети выполняется подключение:  
```bash
sudo nmcli device wifi connect "SSID" password "пароль"
```
Проверка состояния подключения:  
```bash
nmcli connection show
```

---

### Подключение через `wpa_supplicant`  
Для систем без NetworkManager можно использовать `wpa_supplicant`.  

1. Создаётся файл конфигурации Wi-Fi:  
```bash
wpa_passphrase "SSID" "пароль" | sudo tee /etc/wpa_supplicant.conf
```
2. Подключение к сети:  
```bash
sudo wpa_supplicant -B -i wlan0 -c /etc/wpa_supplicant.conf
```
3. Получение IP-адреса через DHCP:  
```bash
sudo dhclient wlan0
```
4. Проверка подключения:  
```bash
ip a show wlan0
ping -c 4 google.com
```

---

### Настройка через Netplan  
Для современных систем, использующих Netplan, Wi-Fi настраивается в файле `/etc/netplan/01-netcfg.yaml`:  
```yaml
network:
  version: 2
  renderer: networkd
  wifis:
    wlan0:
      access-points:
        "SSID":
          password: "пароль"
      dhcp4: true
```
После редактирования файл сохраняется, затем изменения применяются:  
```bash
sudo netplan apply
```

---

### Автоматическое подключение при загрузке  
Для автоматического подключения можно добавить Wi-Fi-сеть в `wpa_supplicant.conf`:  
```bash
sudo nano /etc/wpa_supplicant/wpa_supplicant.conf
```
Добавляется блок:  
```ini
network={
    ssid="SSID"
    psk="пароль"
    key_mgmt=WPA-PSK
}
```
Сохранённые изменения применяются:  
```bash
sudo systemctl restart wpa_supplicant
```

---

### Проверка состояния соединения  
После подключения можно проверить соединение:  
```bash
iwconfig wlan0
nmcli device status
ping -c 4 google.com
```









### Изменение имени хоста и настройка файлов `/etc/hosts` и `/etc/hostname`

**Имя хоста (hostname)** — это уникальное имя компьютера в сети, которое используется для его идентификации. В Linux оно хранится в файле `/etc/hostname` и может быть сопоставлено с IP-адресами в `/etc/hosts`.

---

### Проверка текущего имени хоста  
Чтобы узнать текущее имя хоста, используется команда:  
```bash
hostname
```
Либо:  
```bash
cat /etc/hostname
```

---

### Временное изменение имени хоста  
Можно изменить имя хоста до перезагрузки:  
```bash
sudo hostnamectl set-hostname new-hostname
```
Проверка изменений:  
```bash
hostnamectl
```

Если система не поддерживает `hostnamectl`, можно использовать команду:  
```bash
sudo hostname new-hostname
```
Но это изменение действует только до перезагрузки.

---

### Постоянное изменение имени хоста  

1. Открывается файл `/etc/hostname`:  
```bash
sudo nano /etc/hostname
```
2. Старое имя заменяется на новое, затем файл сохраняется.  

---

### Настройка `/etc/hosts`  
Файл `/etc/hosts` связывает IP-адреса с именами хостов. После изменения имени хоста необходимо обновить этот файл:  
```bash
sudo nano /etc/hosts
```
Здесь должен быть такой формат:  
```ini
127.0.0.1   localhost
127.0.1.1   new-hostname
```
`127.0.1.1` используется для локального имени хоста.

---

### Применение изменений  
После внесения изменений сервис `hostname` можно перезапустить:  
```bash
sudo systemctl restart systemd-hostnamed
```
Или перезагрузить систему:  
```bash
sudo reboot
```
Проверить, применились ли изменения, можно командами:  
```bash
hostname
hostnamectl
cat /etc/hostname
```
Настроенные файлы `/etc/hosts` и `/etc/hostname` обеспечивают правильную работу имени хоста в сети и локально.





### Установка OpenSSH сервера, генерация ключей и настройка конфигурации  

OpenSSH — это набор инструментов для работы с SSH, который обеспечивает безопасное удалённое управление сервером.  

---

### Установка OpenSSH сервера  
В зависимости от дистрибутива установка выполняется следующими командами:  

**Ubuntu / Debian:**  
```bash
sudo apt update
sudo apt install openssh-server -y
```
**AlmaLinux / CentOS / RHEL:**  
```bash
sudo dnf install -y openssh-server
```

После установки OpenSSH включается и запускается:  
```bash
sudo systemctl enable --now ssh
```
Проверить статус можно командой:  
```bash
sudo systemctl status ssh
```

---

### Генерация ключей SSH  
При установке OpenSSH сервер автоматически создаёт ключи, которые хранятся в каталоге:  
```bash
ls -l /etc/ssh/
```
Обычно используются следующие файлы:  
- `/etc/ssh/ssh_host_rsa_key` – закрытый ключ RSA  
- `/etc/ssh/ssh_host_rsa_key.pub` – открытый ключ RSA  
- `/etc/ssh/ssh_host_ecdsa_key` – закрытый ключ ECDSA  
- `/etc/ssh/ssh_host_ed25519_key` – закрытый ключ ED25519  

Эти ключи используются сервером для установления зашифрованного соединения.

Если необходимо сгенерировать новый набор ключей, можно использовать команду:  
```bash
sudo ssh-keygen -A
```

---

### Базовая конфигурация OpenSSH сервера (`/etc/ssh/sshd_config`)  
Основной конфигурационный файл OpenSSH сервера — `/etc/ssh/sshd_config`.  

Открывается для редактирования:  
```bash
sudo nano /etc/ssh/sshd_config
```

**Основные параметры:**  
- **Порт подключения (по умолчанию 22, можно изменить для безопасности)**  
  ```ini
  Port 22
  ```
- **Запрет входа под root (рекомендуется отключить для безопасности)**  
  ```ini
  PermitRootLogin no
  ```
- **Разрешение входа только по ключам (для повышения безопасности)**  
  ```ini
  PasswordAuthentication no
  PubkeyAuthentication yes
  ```
- **Настройка списка разрешённых пользователей**  
  ```ini
  AllowUsers user1 user2
  ```
- **Отключение SSH для определённых пользователей**  
  ```ini
  DenyUsers root test
  ```
После внесения изменений конфигурация перезагружается:  
```bash
sudo systemctl restart ssh
```

---

### Проверка работы OpenSSH сервера  
Для проверки удалённого подключения можно выполнить:  
```bash
ssh user@server-ip
```
Если аутентификация по паролю отключена, необходимо предварительно скопировать SSH-ключи:  
```bash
ssh-copy-id user@server-ip
```








### Указание списка хостов, с которых разрешено подключение с использованием конкретного открытого ключа  

В OpenSSH можно ограничить доступ для конкретных ключей SSH в файле `~/.ssh/authorized_keys`, используя директиву `from="список_хостов"`. Это позволяет разрешить аутентификацию только с определённых IP-адресов или доменов.  

---

### Настройка ограничения по хостам в `authorized_keys`  

1. Открывается файл `~/.ssh/authorized_keys`:  
   ```bash
   nano ~/.ssh/authorized_keys
   ```
2. Перед ключом добавляется директива `from="список_хостов"`, например:  
   ```ini
   from="192.168.1.100" ssh-rsa AAAAB3... пользователь@хост
   ```
   В этом случае доступ будет разрешён только с IP-адреса `192.168.1.100`.  

3. Если нужно разрешить несколько IP-адресов или домены, они указываются через запятую:  
   ```ini
   from="192.168.1.100,192.168.1.101,example.com" ssh-rsa AAAAB3... пользователь@хост
   ```
   Можно использовать маски подсетей:  
   ```ini
   from="192.168.1.*" ssh-rsa AAAAB3... пользователь@хост
   ```

4. После внесения изменений файл сохраняется и закрывается.  

---

### Проверка и тестирование  
После настройки можно попытаться подключиться с разных хостов, чтобы проверить, что доступ разрешён только с указанных адресов.  

Команда для тестирования подключения:  
```bash
ssh user@server-ip
```
Если подключение происходит с запрещённого IP-адреса, сервер SSH отклонит попытку входа.  

Дополнительно можно проверить лог SSH для диагностики:  
```bash
sudo journalctl -u ssh --no-pager | grep "authentication failure"
```

Использование директивы `from="..."` в `authorized_keys` повышает безопасность, ограничивая вход по ключу только с определённых устройств или сетей.






### Ограничение команд для конкретного SSH-ключа  

В OpenSSH можно ограничить список команд, которые разрешено выполнять при подключении по конкретному SSH-ключу. Это делается с помощью директивы `command="..."` в файле `~/.ssh/authorized_keys`.  

---

### Настройка ограниченных команд  

1. Открывается файл `~/.ssh/authorized_keys`:  
   ```bash
   nano ~/.ssh/authorized_keys
   ```
2. Перед ключом добавляется `command="команда"`, например:  
   ```ini
   command="/usr/bin/uptime" ssh-rsa AAAAB3... пользователь@хост
   ```
   В этом случае при подключении по данному ключу будет выполнена только команда `uptime`, после чего соединение закроется.

3. Можно разрешить выполнение только определённого скрипта:  
   ```ini
   command="/home/user/scripts/backup.sh" ssh-rsa AAAAB3... пользователь@хост
   ```
   Это полезно, если нужно разрешить запуск только резервного копирования или других задач.

4. Чтобы запретить открытие интерактивного сеанса и ограничить доступ только до определённой команды, можно комбинировать `command` с `restrict`:  
   ```ini
   command="/home/user/scripts/logs.sh",restrict ssh-rsa AAAAB3... пользователь@хост
   ```

---

### Дополнительные ограничения  

Для ещё большей безопасности можно комбинировать `command` с другими параметрами:  

- **Запрет перенаправления портов, X11, прокси-агента и оболочки:**  
  ```ini
  command="/home/user/scripts/status.sh",no-agent-forwarding,no-port-forwarding,no-X11-forwarding,no-pty ssh-rsa AAAAB3... пользователь@хост
  ```
  В этом случае пользователь не сможет перенаправлять порты, использовать X11 и получать доступ к интерактивному терминалу.

- **Ограничение для нескольких ключей**  
  Можно задать разные команды для разных ключей, если у пользователя несколько SSH-ключей.

---

### Проверка настройки  
После внесения изменений в `authorized_keys` можно протестировать подключение:  
```bash
ssh user@server-ip
```
Если всё настроено правильно, доступ к оболочке будет запрещён, и выполнится только указанная команда.







### Настройка автообновления системы с помощью `unattended-upgrades`

`unattended-upgrades` — это сервис в Debian, Ubuntu и их производных, который автоматически устанавливает обновления безопасности и системные пакеты без участия пользователя.

---

### Установка `unattended-upgrades`  

Если пакет не установлен, его можно установить вручную:  
```bash
sudo apt update
sudo apt install unattended-upgrades -y
```
После установки сервис включается автоматически.

---

### Настройка `/etc/apt/apt.conf.d/50unattended-upgrades`  

Основной конфигурационный файл `unattended-upgrades` находится по пути:  
```bash
sudo nano /etc/apt/apt.conf.d/50unattended-upgrades
```
В нём можно указать, какие пакеты обновлять. По умолчанию включены обновления безопасности:  
```ini
Unattended-Upgrade::Allowed-Origins {
    "origin=Debian,codename=${distro_codename},label=Debian-Security";
    "origin=Ubuntu,codename=${distro_codename},label=Ubuntu-Security";
};
```
Чтобы разрешить установку всех обновлений, можно добавить:  
```ini
    "origin=Debian,codename=${distro_codename},label=Debian";
    "origin=Ubuntu,codename=${distro_codename},label=Ubuntu";
```

Для автоматического удаления устаревших пакетов:  
```ini
Unattended-Upgrade::Remove-Unused-Dependencies "true";
```

---

### Включение автоматического обновления  

Файл `/etc/apt/apt.conf.d/20auto-upgrades` настраивает поведение системы при обновлениях. Если его нет, создаётся новый:  
```bash
sudo nano /etc/apt/apt.conf.d/20auto-upgrades
```
Добавляются строки:  
```ini
APT::Periodic::Update-Package-Lists "1";
APT::Periodic::Unattended-Upgrade "1";
```
Где:  
- `1` — означает включение автообновлений.

---

### Проверка и тестирование  

Чтобы проверить, какие обновления будут установлены, используется команда:  
```bash
sudo unattended-upgrade --dry-run
```
Принудительный запуск обновлений вручную:  
```bash
sudo unattended-upgrade -d
```
Проверить логи можно командой:  
```bash
cat /var/log/unattended-upgrades/unattended-upgrades.log
```

---

### Отключение автоматического обновления  

Если автообновления не нужны, их можно отключить:  
```bash
sudo systemctl stop unattended-upgrades
sudo systemctl disable unattended-upgrades
```
Или изменить конфигурацию `/etc/apt/apt.conf.d/20auto-upgrades`, установив `0` вместо `1`.

Настроенный `unattended-upgrades` позволяет автоматизировать процесс обновлений, повышая безопасность и стабильность системы.





### Настройка ротации логов с помощью `logrotate`  

`logrotate` – это утилита, которая автоматически управляет лог-файлами: ограничивает их размер, удаляет старые записи и архивирует их.  

---

### Проверка установки `logrotate`  

Обычно `logrotate` предустановлен в большинстве дистрибутивов. Чтобы проверить, установлен ли он:  
```bash
logrotate --version
```
Если не установлен, можно установить вручную:  

**Ubuntu / Debian:**  
```bash
sudo apt update
sudo apt install logrotate -y
```
**AlmaLinux / CentOS / RHEL:**  
```bash
sudo dnf install logrotate -y
```

---

### Основные конфигурационные файлы  

- **Глобальная конфигурация:** `/etc/logrotate.conf`  
- **Индивидуальные настройки для сервисов:** `/etc/logrotate.d/`  

Файл `/etc/logrotate.conf` задаёт основные параметры, а в `/etc/logrotate.d/` находятся настройки ротации для отдельных сервисов (например, `nginx`, `syslog`, `apache2`).

---

### Настройка ротации логов  

Пример базовой конфигурации в `/etc/logrotate.conf`:  
```ini
# Проверять ротацию логов раз в день
daily

# Хранить 7 архивных копий
rotate 7

# Сжимать старые логи
compress

# Создавать новый лог после ротации
create

# Если лог пустой, не ротировать
notifempty

# Применять ко всем логам
include /etc/logrotate.d/
```

---

### Создание правила ротации для конкретного лога  

Например, для ротации логов `/var/log/custom.log` создаётся файл:  
```bash
sudo nano /etc/logrotate.d/custom
```
Пример содержимого:  
```ini
/var/log/custom.log {
    weekly        # Ротация раз в неделю
    rotate 4      # Хранить 4 старых файла
    compress      # Сжимать файлы
    missingok     # Не выводить ошибку, если лог отсутствует
    notifempty    # Пропускать, если лог пуст
    create 640 root adm  # Создавать новый файл с правами
    postrotate
        systemctl restart custom-service  # Команда после ротации
    endscript
}
```

---

### Проверка работы `logrotate`  

Проверить конфигурацию перед применением:  
```bash
sudo logrotate -d /etc/logrotate.conf
```
Принудительно выполнить ротацию логов:  
```bash
sudo logrotate -f /etc/logrotate.conf
```
Проверить созданные архивные файлы:  
```bash
ls -lh /var/log/
```

`logrotate` позволяет автоматически управлять логами, предотвращая их переполнение и обеспечивая удобное хранение.










### **`alternatives.log`**
   - **Описание**: Лог, используемый системой управления альтернативами (`update-alternatives`). Он записывает изменения, связанные с настройкой различных версий программ, например, выбор между версиями Java или других утилит.

### **`apport.log`**
   - **Описание**: Лог системы **Apport**, которая собирает информацию о сбоях и ошибках в приложениях. Этот файл используется для диагностики проблем в системе и отправки отчётов о сбоях в баг-трекеры.

### **`auth.log`**
   - **Описание**: Лог, который фиксирует информацию о безопасности системы, в том числе успешные и неудачные попытки входа, авторизации, изменения паролей и других действий, связанных с доступом к системе.

### **`bootstrap.log`**
   - **Описание**: Лог, который записывает информацию о процессе начальной настройки системы (например, после установки ОС или в процессе первой настройки). Он фиксирует все этапы конфигурации, включая установку пакетов и настройку системы.

### **`btmp`**
   - **Описание**: Лог, который содержит информацию о неудачных попытках входа в систему (ошибки при аутентификации). Эти данные полезны для мониторинга безопасности.

### **`cloud-init.log`**
   - **Описание**: Лог, в котором записана информация о процессе инициализации облачной машины с использованием **cloud-init**. В нем фиксируются настройки сети, настройка пользователей и другие параметры, которые настраиваются при запуске в облаке.

### **`cloud-init-output.log`**
   - **Описание**: Этот лог содержит вывод, связанный с процессом выполнения **cloud-init**, например, ошибки и сообщения, возникающие во время начальной настройки системы в облаке.

### **`dist-upgrade`**
   - **Описание**: Каталог, в котором хранятся логи обновлений и апгрейдов, выполненных с помощью команды **`apt dist-upgrade`**. В этом логе сохраняется информация о процессе обновления системы.

### **`dmesg`**
   - **Описание**: Лог, который содержит информацию о событиях ядра, таких как загрузка драйверов, ошибки устройств, сообщения об оборудовании и другие системные события, связанные с ядром Linux.

### **`dpkg.log`**
   - **Описание**: Лог, который записывает информацию об установке, удалении и обновлении пакетов через **dpkg** и **apt**. В нем содержится история всех операций с пакетами.

### **`faillog`**
   - **Описание**: Лог, который используется для записи информации о неудачных попытках входа в систему. Он хранит статистику о неуспешных попытках аутентификации.

### **`installer`**
   - **Описание**: Каталог, в котором хранятся логи, связанные с процессом установки системы, установкой пакетов и настройкой системы во время первого запуска.

### **`journal`**
   - **Описание**: Каталог, в котором содержатся логи системного журнала **systemd**. Эти логи включают информацию о состоянии и событиях системы, а также об ошибках и предупреждениях.

### **`kern.log`**
   - **Описание**: Лог, который фиксирует события, связанные с ядром операционной системы. Он включает информацию о загрузке ядра, драйверах, ошибках оборудования и других системных событиях.

### **`landscape`**
   - **Описание**: Каталог, содержащий логи для **Landscape**, системы управления серверами для Ubuntu. Здесь хранятся отчеты и логи о состоянии серверов и их обновлениях.

### **`lastlog`**
   - **Описание**: Лог, в котором содержится информация о последнем входе каждого пользователя в систему, включая дату и время последнего успешного входа и с какого IP-адреса.

### **`private`**
   - **Описание**: Каталог, который, скорее всего, содержит конфиденциальные данные или логи, доступ к которым ограничен для повышения безопасности системы.

### **`README`**
   - **Описание**: Символьная ссылка, которая ведет к документации по логам **systemd**. Этот файл может содержать важную информацию о конфигурации журналов.

### **`syslog`**
   - **Описание**: Лог-система для записи различных системных событий и сообщений, таких как ошибки приложений, сетевые события, сообщения из демонов и прочее.

### **`sysstat`**
   - **Описание**: Каталог, который используется для хранения статистических данных о производительности системы, таких как загрузка CPU, использование памяти и другие показатели.

### **`unattended-upgrades`**
   - **Описание**: Каталог, в котором записываются логи о автоматических обновлениях безопасности, выполненных с помощью **unattended-upgrades**.

### **`vmware-network.log`**
   - **Описание**: Лог-файл, который используется для записи информации о состоянии сети и настройках в VMware, а также для диагностики проблем, связанных с сетевыми интерфейсами виртуальных машин.

### **`vmware-vmsvc-root.log`**
   - **Описание**: Лог, который записывает информацию о работе виртуальных машин VMware, особенно для диагностики проблем с виртуальными машинами и их сервисами.

### **`vmware-vmtoolsd-root.log`**
   - **Описание**: Лог, который фиксирует события, связанные с VMware Tools, инструментами, которые обеспечивают взаимодействие между хостом и гостевой системой в виртуальной машине.

### **`wtmp`**
   - **Описание**: Лог, который записывает информацию о всех входах и выходах пользователей из системы. Этот лог используется для отслеживания активности пользователей.










### Методы клонирования и переноса системы  

Клонирование системы может выполняться несколькими методами:  
- Полный перенос диска (образа) с помощью `dd`  
- Перенос только файлов с резервным копированием и восстановлением на новом сервере  

---

### **Полное клонирование диска с помощью `dd`**  

Утилита `dd` создаёт точную копию диска или раздела, включая загрузчик и файловую систему.  

#### **Клонирование всего диска**  
Перед началом работы следует определить имена дисков:  
```bash
lsblk
```
Для копирования всего диска `/dev/sda` на `/dev/sdb`:  
```bash
sudo dd if=/dev/sda of=/dev/sdb bs=4M status=progress
```
Где:  
- `if=/dev/sda` – источник  
- `of=/dev/sdb` – целевой диск  
- `bs=4M` – размер блока (увеличивает скорость)  
- `status=progress` – отображает ход выполнения  

После завершения клонирования желательно обновить `UUID` диска:  
```bash
sudo blkid
sudo tune2fs -U random /dev/sdb1
```
Это необходимо, чтобы избежать конфликтов при загрузке.

#### **Создание и восстановление образа диска**  
Если диск нужно сохранить в файл:  
```bash
sudo dd if=/dev/sda of=/mnt/backup/disk_image.img bs=4M status=progress
```
Восстановление выполняется командой:  
```bash
sudo dd if=/mnt/backup/disk_image.img of=/dev/sdb bs=4M status=progress
```

#### **Клонирование только одного раздела**  
Если нужно клонировать только системный раздел (`/dev/sda1`), используется:  
```bash
sudo dd if=/dev/sda1 of=/dev/sdb1 bs=4M status=progress
```
Затем требуется обновить `grub`:  
```bash
sudo grub-install /dev/sdb
sudo update-grub
```

---

### **Перенос системы с резервным копированием и восстановлением**  

Если не требуется копирование всего диска, можно использовать резервное копирование файлов.

#### **Создание резервной копии с `rsync`**  
Команда `rsync` позволяет копировать систему без сохранения ненужных данных, например, виртуальных файловых систем (`/proc`, `/sys`, `/dev`).  
```bash
sudo rsync -aAXv /* /mnt/backup --exclude={"/dev/*","/proc/*","/sys/*","/tmp/*","/run/*","/mnt/*","/media/*","/lost+found"}
```
Где:  
- `-aAX` – сохраняются права, ссылки, владельцы  
- `--exclude={}` – исключение временных директорий  

#### **Восстановление на новом сервере**  
На новом сервере выполняется разворачивание:  
```bash
sudo rsync -aAXv /mnt/backup/ /
```
После восстановления требуется:  
- Обновить `fstab`:  
  ```bash
  sudo nano /etc/fstab
  ```
- Установить загрузчик:  
  ```bash
  sudo grub-install /dev/sda
  sudo update-grub
  ```

---

### **Выбор метода клонирования**  
| Метод | Преимущества | Недостатки |
|--------|--------------|--------------|
| `dd` (полное клонирование) | Полный перенос системы, включая загрузчик, MBR, разделы | Долгое копирование, копирует пустое пространство |
| `rsync` (копирование файлов) | Гибкость, перенос только нужных файлов, можно исключать каталоги | Требуется настройка загрузчика и `fstab` вручную |

Оба метода подходят для миграции системы, но `dd` лучше использовать при необходимости полного клонирования, а `rsync` – для переносов без ненужных данных.







### **Добавление нового диска в Linux**  

При подключении нового диска в Linux его необходимо инициализировать, создать разделы, отформатировать и примонтировать.  

---

### **Проверка нового диска**  
После подключения нового диска его можно обнаружить с помощью команд:  
```bash
lsblk
fdisk -l
```
Новый диск обычно определяется как `/dev/sdb`, если основной диск — `/dev/sda`.  

---

### **Создание разделов на новом диске**  
Для разметки диска используется `fdisk`:  
```bash
sudo fdisk /dev/sdb
```
В интерактивном режиме выполняются следующие шаги:  
- Нажать **`n`** (создать новый раздел)  
- Выбрать **`p`** (основной раздел)  
- Подтвердить номера секторов (по умолчанию — весь диск)  
- Нажать **`w`** (сохранить изменения и выйти)  

После этого раздел появится как `/dev/sdb1`.  

Альтернативный способ разметки с `parted`:  
```bash
sudo parted /dev/sdb mklabel gpt
sudo parted /dev/sdb mkpart primary ext4 0% 100%
```

---

### **Форматирование раздела**  
После создания раздела его необходимо отформатировать. Например, в `ext4`:  
```bash
sudo mkfs.ext4 /dev/sdb1
```
Для XFS (актуально для RHEL):  
```bash
sudo mkfs.xfs /dev/sdb1
```

---

### **Монтирование диска**  
Для использования диска создаётся точка монтирования:  
```bash
sudo mkdir /mnt/newdisk
```
Монтирование выполняется командой:  
```bash
sudo mount /dev/sdb1 /mnt/newdisk
```
Проверка успешного монтирования:  
```bash
df -h
```

---

### **Автоматическое монтирование при загрузке (`/etc/fstab`)**  
Чтобы диск монтировался автоматически после перезагрузки, его `UUID` добавляется в `/etc/fstab`:  
```bash
blkid /dev/sdb1
```
Вывод будет примерно таким:  
```bash
/dev/sdb1: UUID="1234-abcd" TYPE="ext4"
```
Редактируется файл `/etc/fstab`:  
```bash
sudo nano /etc/fstab
```
Добавляется строка:  
```ini
UUID=1234-abcd /mnt/newdisk ext4 defaults 0 2
```
После этого монтирование проверяется командой:  
```bash
sudo mount -a
```








### **Форматирование диска в Linux**  

Перед форматированием нужно определить, какой диск используется, создать раздел (если он отсутствует) и выбрать файловую систему.  

---

### **Проверка подключённых дисков**  
Список доступных дисков можно посмотреть командами:  
```bash
lsblk
fdisk -l
```
Если диск `/dev/sdb`, а раздел `/dev/sdb1`, нужно отформатировать именно раздел `/dev/sdb1`, а не весь диск.

---

### **Форматирование раздела**  

Форматирование выполняется в зависимости от выбранной файловой системы:  

**Форматирование в `ext4` (универсальная система для Linux)**  
```bash
sudo mkfs.ext4 /dev/sdb1
```

**Форматирование в `XFS` (актуально для RHEL и CentOS)**  
```bash
sudo mkfs.xfs /dev/sdb1
```

**Форматирование в `NTFS` (если диск нужен для Windows и Linux)**  
```bash
sudo mkfs.ntfs /dev/sdb1
```

**Форматирование в `FAT32` (поддерживается в Windows, Mac и Linux, но ограничение по файлам 4 ГБ)**  
```bash
sudo mkfs.vfat -F32 /dev/sdb1
```

---

### **Проверка файловой системы после форматирования**  
Проверить файловую систему можно командой:  
```bash
sudo blkid /dev/sdb1
```

---

### **Монтирование после форматирования**  

Создаётся точка монтирования:  
```bash
sudo mkdir /mnt/newdisk
```
Монтирование выполняется командой:  
```bash
sudo mount /dev/sdb1 /mnt/newdisk
```
Проверка доступного пространства:  
```bash
df -h
```

Чтобы диск автоматически монтировался после перезагрузки, его `UUID` добавляется в `/etc/fstab`:  
```bash
blkid /dev/sdb1
```
Редактируется файл `/etc/fstab`:  
```bash
sudo nano /etc/fstab
```
Добавляется строка (пример для `ext4`):  
```ini
UUID=1234-abcd /mnt/newdisk ext4 defaults 0 2
```
Применить изменения можно командой:  
```bash
sudo mount -a
```







### **Добавление нового диска в группу томов (VG) в LVM**  

LVM (Logical Volume Manager) позволяет объединять несколько дисков в одну группу томов (VG), что даёт гибкость при управлении пространством.

---

### **Проверка нового диска**  
Перед добавлением в LVM нужно проверить доступные устройства:  
```bash
lsblk
fdisk -l
```
Допустим, новый диск – `/dev/sdb`.

---

### **Создание физического тома (PV) на новом диске**  
Прежде чем добавить диск в группу томов, его нужно инициализировать в LVM:  
```bash
sudo pvcreate /dev/sdb
```
Проверить статус можно командой:  
```bash
sudo pvdisplay
```

---

### **Добавление физического тома в группу томов (VG)**  
Сначала проверяется, какие группы томов уже существуют:  
```bash
sudo vgdisplay
```
Допустим, есть группа томов `vg01`. Добавить диск `/dev/sdb` в `vg01` можно командой:  
```bash
sudo vgextend vg01 /dev/sdb
```
Проверка успешного добавления:  
```bash
sudo vgdisplay vg01
```

---

### **Расширение логического тома (LV)**  
После добавления диска в VG можно увеличить размер логического тома (`/dev/vg01/lv_root`):  
```bash
sudo lvextend -l +100%FREE /dev/vg01/lv_root
```
Если файловая система `ext4`, то после расширения её нужно увеличить командой:  
```bash
sudo resize2fs /dev/vg01/lv_root
```
Для `XFS` вместо `resize2fs` используется:  
```bash
sudo xfs_growfs /dev/vg01/lv_root
```

---

### **Проверка изменений**  
После расширения можно проверить доступное пространство:  
```bash
df -h
sudo lvs
sudo vgs
sudo pvs
```







### **Добавление логического тома (LV) в LVM**  

Логические тома (LV) в LVM позволяют гибко управлять дисковым пространством, создавая виртуальные разделы внутри группы томов (VG).  

---

### **Проверка существующих групп томов**  
Перед созданием логического тома нужно проверить, какие группы томов уже есть в системе:  
```bash
sudo vgs
```
Если группа томов отсутствует, её можно создать с использованием физического тома (PV):  
```bash
sudo vgcreate vg01 /dev/sdb
```
Проверка информации о группе томов:  
```bash
sudo vgdisplay vg01
```

---

### **Создание нового логического тома**  

**Создание LV фиксированного размера (например, 10 ГБ):**  
```bash
sudo lvcreate -L 10G -n lv_data vg01
```

**Создание LV, используя всё доступное пространство:**  
```bash
sudo lvcreate -l 100%FREE -n lv_data vg01
```
Проверка созданного LV:  
```bash
sudo lvs
sudo lvdisplay /dev/vg01/lv_data
```

---

### **Форматирование логического тома**  

Перед использованием LV его необходимо отформатировать.  

**Форматирование в ext4:**  
```bash
sudo mkfs.ext4 /dev/vg01/lv_data
```

**Форматирование в XFS (рекомендуется для RHEL):**  
```bash
sudo mkfs.xfs /dev/vg01/lv_data
```

---

### **Монтирование логического тома**  

Создание точки монтирования:  
```bash
sudo mkdir /mnt/data
```
Монтирование LV:  
```bash
sudo mount /dev/vg01/lv_data /mnt/data
```
Проверка монтирования:  
```bash
df -h
```

---

### **Автоматическое монтирование при загрузке**  

Чтобы LV автоматически монтировался после перезагрузки, нужно получить его UUID:  
```bash
blkid /dev/vg01/lv_data
```
Редактирование файла `/etc/fstab`:  
```bash
sudo nano /etc/fstab
```
Добавление строки (заменить `UUID=xxxx` на реальный UUID):  
```ini
UUID=xxxx /mnt/data ext4 defaults 0 2
```
Применение изменений:  
```bash
sudo mount -a
```

---

### **Расширение существующего логического тома**  

Если нужно увеличить размер существующего LV:  
```bash
sudo lvextend -L +5G /dev/vg01/lv_data
```
Или использовать всё доступное место:  
```bash
sudo lvextend -l +100%FREE /dev/vg01/lv_data
```

После расширения необходимо увеличить файловую систему:  

**Для ext4:**  
```bash
sudo resize2fs /dev/vg01/lv_data
```

**Для XFS:**  
```bash
sudo xfs_growfs /dev/vg01/lv_data
```

---

### **Проверка изменений**  

Проверка обновлённого дискового пространства:  
```bash
df -h
sudo lvs
```

